settings
{
	main
	{
		Description: "Melee Hitbox (MHB) Visualizer by pluzorminuz. Last Update: 2020 Dec 26. Supported Abilities: All melee (excl. Brig Flail and Torb Hammer), Blade, Charge, Tesla Cannon."
	}

	modes
	{
		disabled Practice Range
		{
			Training Partner: Off
		}

		Team Deathmatch
		{
			enabled maps
			{
				Workshop Expanse Night
			}
		}

		General
		{
			Game Mode Start: Manual
			Hero Limit: Off
			Respawn Time Scalar: 40%
		}
	}

	heroes
	{
		General
		{
			Ability Cooldown Time: 20%
			No Ammunition Requirement: On
			Spawn With Ultimate Ready: On
			Ultimate Generation: 500%
			Ultimate Generation - Passive: 500%
		}
	}

	workshop
	{
		Sphere Count: 8
	}
}

variables
{
	global:
		0: all_mhb
		1: loop_i
		2: arr_temp
		3: hero_mhb_indexmatrix
		4: mhb_dimensions
		5: global_knockback_disable
		6: global_total_effect_count
		7: global_total_hudtext_count
		8: settings
		9: color_global
		10: color_settings

	player:
		0: self_mhb
		1: self_mhb_temp
		2: loop_j
		3: player_hero
		4: mhb_target
		5: player_effect_colors_melee
		6: player_effect_id
		7: player_scale
		8: temp_arr
		9: temp_arr2
		10: player_hudtext_id
		11: temp_arr3
		12: player_cone1_dimensions
}

subroutines
{
	0: init_div
	1: create_body_mhb
	2: create_melee_hitbox_quick
	3: create_melee_hitbox_root
	4: destroy_melee_hitbox
	5: create_melee_hitbox_reinhammer
	6: pass
	7: create_cone1_hitbox_root
	8: destory_cone1_hitbox
	9: create_cone1_hitbox_winstontesla
	10: create_cone1_hitbox_reincharge
	11: create_cone1_hitbox_genjiblade
}

rule("bot scale for fun")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		If(Random Integer(0, 1) == 0);
			Start Scaling Player(Event Player, Event Player.player_scale, True);
			Chase Player Variable At Rate(Event Player, player_scale, 5, 0.200, Destination and Rate);
		End;
	}
}

disabled rule("bot duck")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Crouch));
		Wait(5, Ignore Condition);
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(5, Ignore Condition);
		Loop;
	}
}

rule("init")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		disabled Disable Inspector Recording;
		Global.color_settings = Array(Workshop Setting Combo(Custom String("Display - Body Melee Hurtbox"), Custom String("Color"), 1,
			Array(Custom String("White"), Custom String("Green"), Custom String("Blue"), Custom String("Yellow"), Custom String("Gray"),
			Custom String("Red"), Custom String("Turquoise"), Custom String("Aqua"), Custom String("Rose")), 0), Workshop Setting Combo(
			Custom String("Display - Melee Hitbox"), Custom String("Idle Color"), 2, Array(Custom String("White"), Custom String("Green"),
			Custom String("Blue"), Custom String("Yellow"), Custom String("Gray"), Custom String("Red"), Custom String("Turquoise"),
			Custom String("Aqua"), Custom String("Rose")), 0), Workshop Setting Combo(Custom String("Display - Melee Hitbox"),
			Custom String("Active Color"), 3, Array(Custom String("White"), Custom String("Green"), Custom String("Blue"), Custom String(
			"Yellow"), Custom String("Gray"), Custom String("Red"), Custom String("Turquoise"), Custom String("Aqua"), Custom String(
			"Rose")), 1), Workshop Setting Combo(Custom String("Display - Cone"), Custom String("Cone Color"), 4, Array(Custom String(
			"White"), Custom String("Green"), Custom String("Blue"), Custom String("Yellow"), Custom String("Gray"), Custom String("Red"),
			Custom String("Turquoise"), Custom String("Aqua"), Custom String("Rose")), 7));
		Global.color_global = Array(Color(White), Color(Green), Color(Blue), Color(Yellow), Color(Gray), Color(Red), Color(Turquoise),
			Color(Aqua), Color(Rose));
		Global.settings = Array(Workshop Setting Toggle(Custom String("Display - Cone"), Custom String("Use Beams"), True, 0),
			Workshop Setting Toggle(Custom String("Display - Cone"), Custom String("Show Circle (lag warning!!!)"), False, 1),
			Workshop Setting Toggle(Custom String("Display - Cone"), Custom String("Use Spheres"), False, 3), Workshop Setting Integer(
			Custom String("Display - Cone"), Custom String("Beam Count"), 8, 4, 16, 2), Workshop Setting Integer(Custom String(
			"Display - Cone"), Custom String("Animation Speed (deg/s)"), 30, 1, 360, 5), Workshop Setting Integer(Custom String(
			"Display - Cone"), Custom String("Sphere Count"), 12, 4, 32, 4));
		Global.global_knockback_disable = Workshop Setting Toggle(Custom String("Global"), Custom String("Disable Knockback?"), True, 0);
		"melee hitbox dimensions [0]r [1]dist_from_eye"
		Global.mhb_dimensions = Array(1, 1.500);
		Global.hero_mhb_indexmatrix = Array(Array(0, 0, 0), Array(0, 6, 0), Array(0, 0, 0), Array(0, 0, 0), Array(0, 5, 0), Array(1, 1, 1),
			Array(0, 0, 0), Array(1, 2, 1), Array(0, 0, 0), Array(1, 1, 1), Array(0, 0, 0), Array(0, 0, 0), Array(0, 0, 0), Array(1, 1, 1),
			Array(0, 0, 0), Array(0, 0, 0), Array(0, 0, 0), Array(0, 0, 0), Array(0, 0, 0), Array(1, 0, 1), Array(0, 3, 0), Array(0, 4, 0),
			Array(1, 1, 1), Array(0, 0, 0), Array(1, 1, 1), Array(0, 0, 0), Array(0, 0, 0), Array(2, 0, 3), Array(0, 0, 0), Array(0, 0, 0),
			Array(0, 0, 0), Array(1, 2, 2));
		Global.all_mhb = Empty Array;
		Global.arr_temp = Empty Array;
		"mhb radius"
		disabled Global.arr_temp = Array(500, 699.707, 949.707);
		"mhb radius 2"
		Global.arr_temp = Array(500, 700, 950);
		Call Subroutine(init_div);
		Global.all_mhb[0] = Global.arr_temp;
		"mhb standing height"
		disabled Global.arr_temp = Array(1999.020, 2298.830, 2499.020, 1968.750, 1885.740, 1548.830, 1992.190);
		"mhb standing height 2"
		Global.arr_temp = Array(2000, 2300, 2500, 1968.750, 2000, 1548.830, 1993);
		Call Subroutine(init_div);
		Global.all_mhb[1] = Global.arr_temp;
		"mhb ducking height"
		disabled Global.arr_temp = Array(1298.830, 1718.750, 2048.830, 1999.020);
		"mhb ducking height"
		Global.arr_temp = Array(1298.830, 1718.750, 2048.830, 1999.020);
		Call Subroutine(init_div);
		Global.all_mhb[2] = Global.arr_temp;
		Global.arr_temp = Empty Array;
		Create HUD Text(All Players(All Teams), Custom String("Code: YASRJ"), Custom String("The MHB Visualizer (201226)"), Custom String(
			"by pluzorminuz"), Top, 1, Color(Yellow), Color(White), Color(Aqua), Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), String("{0} {1}", Custom String("effect count"), Global.global_total_effect_count), Null,
			Null, Right, 2, Color(Gray), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), String("{0} {1}", Custom String("hud text count"), Global.global_total_hudtext_count),
			Null, Null, Right, 2.100, Color(Gray), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), String("{0} {1} {2}", Server Load, Server Load Average, Server Load Peak), Null, Null,
			Right, 1, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Custom String("[ACKNOWLEDGE] Switch Hero"), Null, Null, Top, 2, Color(White), Color(White),
			Color(Aqua), Visible To, Default Visibility);
		Global.global_total_hudtext_count += 5;
	}
}

rule("Dummy Bot Test")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Create Dummy Bot(Random Value In Array(All Heroes), Team 2, -1, Vector(0, -1000, 0), Vector(0, 0, 0));
		Create Dummy Bot(Random Value In Array(All Heroes), Team 2, -1, Vector(0, -1000, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Random Value In Array(All Heroes), Team 2, -1, Vector(0, -1000, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Tracer), Team 2, -1, Vector(0, -1000, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Sombra), Team 2, -1, Vector(0, -1000, 0), Vector(0, 0, 0));
		Create Dummy Bot(Hero(Winston), Team 2, -1, Vector(0, -1000, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Sigma), Team 2, -1, Vector(0, -1000, 0), Vector(0, 0, 0));
	}
}

rule("player_init_once")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
		Event Player.temp_arr3 = Empty Array;
		Event Player.player_effect_id = Empty Array;
		Event Player.player_hudtext_id = Empty Array;
		Event Player.player_scale = 1;
		Call Subroutine(create_body_mhb);
	}
}

rule("player_change_hero_init")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.player_hero != Hero Of(Event Player);
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.player_hero = Hero Of(Event Player);
		Event Player.self_mhb_temp = Global.hero_mhb_indexmatrix[Index Of Array Value(All Heroes, Hero Of(Event Player))];
		For Player Variable(Event Player, loop_j, 0, Count Of(Event Player.self_mhb_temp), 1);
			Event Player.self_mhb_temp[Event Player.loop_j] = Global.all_mhb[Event Player.loop_j][Event Player.self_mhb_temp[Event Player.loop_j]];
		End;
		Event Player.self_mhb = Array(Event Player.self_mhb_temp[0], Vector(0, Event Player.self_mhb_temp[0], 0), Vector(0,
			Event Player.self_mhb_temp[1] - Event Player.self_mhb_temp[0], 0), Null, Vector(0,
			Event Player.self_mhb_temp[1] - Event Player.self_mhb_temp[0], 0), Vector(0,
			Event Player.self_mhb_temp[2] - Event Player.self_mhb_temp[0], 0));
		Event Player.self_mhb[3] = Event Player.self_mhb[2] - Event Player.self_mhb[1];
		Call Subroutine(create_melee_hitbox_root);
		Call Subroutine(create_cone1_hitbox_root);
	}
}

rule("player_no_knockback")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.global_knockback_disable == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Set Knockback Dealt(Event Player, 0);
		Set Knockback Received(Event Player, 0);
	}
}

rule("player_crouch_true_mhb_switch")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Crouching(Event Player) == True;
	}

	actions
	{
		Event Player.self_mhb[2] = Event Player.self_mhb[5];
		Event Player.self_mhb[3] = Event Player.self_mhb[2] - Event Player.self_mhb[1];
	}
}

rule("player_crouch_false_mhb_switch")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Crouching(Event Player) == False;
	}

	actions
	{
		Event Player.self_mhb[2] = Event Player.self_mhb[4];
		Event Player.self_mhb[3] = Event Player.self_mhb[2] - Event Player.self_mhb[1];
	}
}

rule("kill self")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Acknowledge) == True;
	}

	actions
	{
		Kill(Event Player, Null);
	}
}

rule("[sub] divide init array")
{
	event
	{
		Subroutine;
		init_div;
	}

	actions
	{
		For Global Variable(loop_i, 0, Count Of(Global.arr_temp), 1);
			Global.arr_temp[Global.loop_i] /= 1000;
		End;
	}
}

rule("select_player_near_crosshair_mhb_target")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		Event Player.mhb_target = Player Closest To Reticle(Event Player, Opposite Team Of(Team Of(Event Player)));
	}
}

rule("damage_indicator_melee")
{
	event
	{
		Player Dealt Damage;
		All;
		All;
	}

	actions
	{
		Small Message(All Players(All Teams), String("{0} {1} {2}", Custom String("damaged"), Victim, Event Damage));
	}
}

rule("melee change melee_hitbox color")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Meleeing(Event Player) == True;
	}

	actions
	{
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[2]];
		Wait(0.176, Ignore Condition);
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[1]];
	}
}

rule("bot_shield")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Add Health Pool To Player(Event Player, Shields, 300, True, True);
	}
}

rule("[sub] all hero body melee hurtbox")
{
	event
	{
		Subroutine;
		create_body_mhb;
	}

	actions
	{
		"create melee hurtbox"
		For Player Variable(Event Player, loop_j, 0, 4, 1);
			Create Effect(All Players(Opposite Team Of(Team Of(Event Player))), Sphere, Global.color_global[Global.color_settings[0]],
				Position Of(Event Player) + Event Player.player_scale * ((1 - Evaluate Once(Event Player.loop_j) / 3)
				* Event Player.self_mhb[1] + Evaluate Once(Event Player.loop_j) / 3 * Event Player.self_mhb[2]),
				Event Player.player_scale * Event Player.self_mhb[0] / 0.985, Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
		"end create melee hurtbox"
		End;
		"no need to create hud text for dummies"
		If(Is Dummy Bot(Event Player) != True);
			"mhb looking at"
			Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("Looking at"), Player Closest To Reticle(Event Player,
				Opposite Team Of(Team Of(Event Player))), Hero Icon String(Hero Of(Player Closest To Reticle(Event Player, Opposite Team Of(
				Team Of(Event Player)))))), Null, Null, Left, 0, Color(White), Color(White), Color(White), String, Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			"mhb selected target"
			Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("[Interact] Selected"), Event Player.mhb_target,
				Hero Icon String(Hero Of(Event Player.mhb_target))), Null, Null, Left, 1, Global.color_global[Global.color_settings[1]], Color(
				White), Color(White), String, Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
		End;
		"temp_arr for EFFECTS"
		Global.global_total_effect_count += Count Of(Event Player.temp_arr);
		"temp_arr2 for HUD TEXT"
		Global.global_total_hudtext_count += Count Of(Event Player.temp_arr2);
		"player_effect_id[0] for mhb body"
		Event Player.player_effect_id[0] = Event Player.temp_arr;
		Event Player.player_hudtext_id[0] = Event Player.temp_arr2;
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
	}
}

rule("[sub] create melee hitbox quick + hud")
{
	event
	{
		Subroutine;
		create_melee_hitbox_quick;
	}

	actions
	{
		"no need to create hud text for dummies"
		If(Is Dummy Bot(Event Player) != True);
			"melee predict"
			Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("Melee Distance"), 100 * (Distance Between(Eye Position(
				Event Player) + Global.mhb_dimensions[1] * Event Player.player_scale * Facing Direction Of(Event Player), Position Of(
				Event Player.mhb_target) + Event Player.mhb_target.self_mhb[1] * Event Player.mhb_target.player_scale + Min(Max(Dot Product(
				Eye Position(Event Player) + Global.mhb_dimensions[1] * Event Player.player_scale * Facing Direction Of(Event Player)
				- Position Of(Event Player.mhb_target) - Event Player.mhb_target.self_mhb[1] * Event Player.mhb_target.player_scale,
				Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale) / Dot Product(
				Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale,
				Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale), 0), 1)
				* Event Player.mhb_target.player_scale * Event Player.mhb_target.self_mhb[3])
				- Event Player.mhb_target.self_mhb[0] * Event Player.mhb_target.player_scale - Global.mhb_dimensions[0] * Event Player.player_scale),
				Custom String("cm")), Null, Null, Left, 2, Global.color_global[Global.color_settings[2]], Color(White), Color(White), String,
				Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
		End;
		"melee hitbox color"
		Event Player.player_effect_colors_melee = Array(Global.color_global[Global.color_settings[1]]);
		"create melee hitbox"
		Create Effect(All Players(All Teams), Sphere, Event Player.player_effect_colors_melee[0], Eye Position(Event Player)
			+ Global.mhb_dimensions[1] * Facing Direction Of(Event Player) * Event Player.player_scale,
			Event Player.player_scale * Global.mhb_dimensions[0] / 0.985, Visible To Position Radius and Color);
		Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
		disabled Event Player.player_effect_id[1] = Array(Event Player.temp_arr);
		"temp_arr for EFFECTS"
		Global.global_total_effect_count += Count Of(Event Player.temp_arr);
		"temp_arr2 for HUD TEXT"
		Global.global_total_hudtext_count += Count Of(Event Player.temp_arr2);
		"player_effect_id[1] for melee"
		Event Player.player_effect_id[1] = Event Player.temp_arr;
		Event Player.player_hudtext_id[1] = Event Player.temp_arr2;
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
	}
}

rule("[sub] create melee hitbox root")
{
	event
	{
		Subroutine;
		create_melee_hitbox_root;
	}

	actions
	{
		Call Subroutine(destroy_melee_hitbox);
		If(Hero Of(Event Player) == Hero(Reinhardt));
			Call Subroutine(create_melee_hitbox_reinhammer);
		Else If(Hero Of(Event Player) == Hero(Brigitte));
			Call Subroutine(pass);
		Else;
			Call Subroutine(create_melee_hitbox_quick);
		End;
	}
}

rule("[sub] destory melee hitbox")
{
	event
	{
		Subroutine;
		destroy_melee_hitbox;
	}

	actions
	{
		Event Player.temp_arr = Event Player.player_effect_id[1];
		Event Player.temp_arr2 = Event Player.player_hudtext_id[1];
		Global.global_total_effect_count -= Count Of(Event Player.temp_arr);
		Global.global_total_hudtext_count -= Count Of(Event Player.temp_arr2);
		"destroy melee effect"
		While(Event Player.temp_arr != Empty Array);
			Destroy Effect(Event Player.temp_arr[0]);
			Modify Player Variable(Event Player, temp_arr, Remove From Array By Index, 0);
			Wait(0.016, Ignore Condition);
		End;
		"destroy melee hud text"
		While(Event Player.temp_arr2 != Empty Array);
			Destroy HUD Text(Event Player.temp_arr2[0]);
			Modify Player Variable(Event Player, temp_arr2, Remove From Array By Index, 0);
			Wait(0.016, Ignore Condition);
		End;
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
		Event Player.player_effect_id[1] = Empty Array;
		Event Player.player_hudtext_id[1] = Empty Array;
	}
}

rule("[sub] create melee hitbox rein hammer")
{
	event
	{
		Subroutine;
		create_melee_hitbox_reinhammer;
	}

	actions
	{
		"no need to create hud text for dummies"
		If(Is Dummy Bot(Event Player) != True);
		End;
		"rein hammer hitbox color"
		Event Player.player_effect_colors_melee = Array(Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]]);
		"rein hammer data"
		Event Player.temp_arr3 = Array(Array(Vector(-2, -0.300, 3), Vector(-1, -0.300, 1.500)), Array(Vector(-0.920, -0.300, 3), Vector(
			-0.460, -0.300, 1.500)), Array(Vector(-0.280, -0.300, 3), Vector(-0.140, -0.300, 1.500)), Array(Vector(0.360, -0.300, 3),
			Vector(0.180, -0.300, 1.500)), Array(Vector(1, -0.300, 3), Vector(0.500, -0.300, 1.500)), Array(Vector(1.640, -0.300, 3),
			Vector(0.820, -0.300, 1.500)), Array(Vector(2, -0.300, 3), Vector(1, -0.300, 1.500)), Array(Vector(1.200, -0.300, 3), Vector(
			0.600, -0.300, 1.500)), Array(Vector(0.560, -0.300, 3), Vector(0.280, -0.300, 1.500)), Array(Vector(-0.080, -0.300, 3), Vector(
			-0.040, -0.300, 1.500)), Array(Vector(-0.720, -0.300, 3), Vector(-0.360, -0.300, 1.500)), Array(Vector(-1.360, -0.300, 3),
			Vector(-0.680, -0.300, 1.500)));
		"create rein hammer hitbox"
		For Player Variable(Event Player, loop_j, 0, Count Of(Event Player.temp_arr3), 1);
			Create Effect(All Players(All Teams), Sphere, Event Player.player_effect_colors_melee[Evaluate Once(Event Player.loop_j)],
				Eye Position(Event Player) + Event Player.player_scale * (World Vector Of(Left, Event Player, Rotation) * Evaluate Once(
				X Component Of(Event Player.temp_arr3[Event Player.loop_j][0])) + Direction From Angles(Horizontal Facing Angle Of(
				Event Player), Vertical Facing Angle Of(Event Player) - 90) * Evaluate Once(Y Component Of(
				Event Player.temp_arr3[Event Player.loop_j][0])) + Facing Direction Of(Event Player) * Evaluate Once(Z Component Of(
				Event Player.temp_arr3[Event Player.loop_j][0]))), 1 * Event Player.player_scale / 0.985,
				Visible To Position Radius and Color);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			Create Effect(All Players(All Teams), Sphere, Event Player.player_effect_colors_melee[Evaluate Once(Event Player.loop_j)],
				Eye Position(Event Player) + Event Player.player_scale * (World Vector Of(Left, Event Player, Rotation) * Evaluate Once(
				X Component Of(Event Player.temp_arr3[Event Player.loop_j][1])) + Direction From Angles(Horizontal Facing Angle Of(
				Event Player), Vertical Facing Angle Of(Event Player) - 90) * Evaluate Once(Y Component Of(
				Event Player.temp_arr3[Event Player.loop_j][1])) + Facing Direction Of(Event Player) * Evaluate Once(Z Component Of(
				Event Player.temp_arr3[Event Player.loop_j][1]))), 0.500 * Event Player.player_scale / 0.985,
				Visible To Position Radius and Color);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			Wait(0.016, Ignore Condition);
		End;
		"temp_arr for EFFECTS"
		Global.global_total_effect_count += Count Of(Event Player.temp_arr);
		"temp_arr2 for HUD TEXT"
		disabled Global.global_total_hudtext_count += Count Of(Event Player.temp_arr2);
		"player_effect_id[1] for melee"
		Event Player.player_effect_id[1] = Event Player.temp_arr;
		disabled Event Player.player_hudtext_id[1] = Event Player.temp_arr2;
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
		Event Player.temp_arr3 = Empty Array;
	}
}

rule("[sub] nothing")
{
	event
	{
		Subroutine;
		pass;
	}
}

rule("[REIN] rein_hammer_swing_change_color")
{
	event
	{
		Ongoing - Each Player;
		All;
		Reinhardt;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		Wait(0.432, Ignore Condition);
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[2]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[1] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[2] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[1] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[3] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[2] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[4] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[3] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[5] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[4] = Global.color_global[Global.color_settings[1]];
		"33"
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[6] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[5] = Global.color_global[Global.color_settings[1]];
		Wait(0.416, Ignore Condition);
		Event Player.player_effect_colors_melee[6] = Global.color_global[Global.color_settings[1]];
		Wait(0.064, Ignore Condition);
		Abort If Condition Is False;
		Wait(0.352, Ignore Condition);
		Event Player.player_effect_colors_melee[6] = Global.color_global[Global.color_settings[2]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[7] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[6] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[8] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[7] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[9] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[8] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[10] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[9] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[11] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[10] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[11] = Global.color_global[Global.color_settings[1]];
		Wait(0.256, Ignore Condition);
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[1]];
		Wait(0.192, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[sub] [WINSTON] create cone1 winston tesla")
{
	event
	{
		Subroutine;
		create_cone1_hitbox_winstontesla;
	}

	actions
	{
		Event Player.player_cone1_dimensions = Array(8, 20);
		Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[3]], Position Of(Event Player) + Vector(0,
			Event Player.player_scale, 0), Event Player.player_cone1_dimensions[0] * Event Player.player_scale / 0.985,
			Visible To Position and Radius);
		Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
		If(Global.settings[0] == True);
			For Player Variable(Event Player, loop_j, 0, Global.settings[3], 1);
				Create Beam Effect(All Players(All Teams), Grapple Beam, Position Of(Event Player) + Vector(0, Event Player.player_scale, 0),
					Position Of(Event Player) + Vector(0, Event Player.player_scale, 0) + World Vector Of(Left, Event Player, Rotation)
					* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
					Event Player.player_cone1_dimensions[1])) * Cosine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3]))
					+ Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Direction From Angles(Horizontal Facing Angle Of(Event Player),
					Vertical Facing Angle Of(Event Player) - 90) * Event Player.player_scale * Evaluate Once(
					Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
					* Sine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
					* Total Time Elapsed) + Facing Direction Of(Event Player) * Event Player.player_scale * Evaluate Once(
					Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(Event Player.player_cone1_dimensions[1])), Color(
					White), Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				If(Global.settings[1] == True);
					Create Beam Effect(All Players(All Teams), Grapple Beam, Position Of(Event Player) + Vector(0, Event Player.player_scale, 0)
						+ World Vector Of(Left, Event Player, Rotation) * Event Player.player_scale * Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
						* Cosine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
						* Total Time Elapsed) + Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player)
						- 90) * Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
						Event Player.player_cone1_dimensions[1])) * Sine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3]))
						+ Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Facing Direction Of(Event Player)
						* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(
						Event Player.player_cone1_dimensions[1])), Position Of(Event Player) + Vector(0, Event Player.player_scale, 0)
						+ World Vector Of(Left, Event Player, Rotation) * Event Player.player_scale * Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
						* Cosine From Degrees(Evaluate Once((Event Player.loop_j + 1) * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
						* Total Time Elapsed) + Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player)
						- 90) * Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
						Event Player.player_cone1_dimensions[1])) * Sine From Degrees(Evaluate Once((Event Player.loop_j + 1) * (
						360 / Global.settings[3])) + Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Facing Direction Of(Event Player)
						* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(
						Event Player.player_cone1_dimensions[1])), Color(White), Visible To Position and Radius);
					Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				End;
				Wait(0.032, Ignore Condition);
			End;
		End;
		If(Global.settings[2] == True);
			For Player Variable(Event Player, loop_j, 0, Global.settings[5], 1);
				Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[3]], Position Of(Event Player) + Vector(0,
					Event Player.player_scale, 0) + Facing Direction Of(Event Player) * (Evaluate Once(
					Event Player.loop_j * Event Player.player_cone1_dimensions[0]) * Event Player.player_scale / Evaluate Once((
					Global.settings[5] - 1) * Cosine From Degrees(Event Player.player_cone1_dimensions[1]))),
					Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0] * Event Player.loop_j * Tangent From Degrees(
					Event Player.player_cone1_dimensions[1]) / (Global.settings[5] - 1)) / 0.985, Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				Wait(0.032, Ignore Condition);
			End;
		End;
		"temp_arr for EFFECTS"
		Global.global_total_effect_count += Count Of(Event Player.temp_arr);
		"player_effect_id[1] for melee"
		Event Player.player_effect_id[2] = Event Player.temp_arr;
		Event Player.temp_arr = Empty Array;
	}
}

rule("[sub] create cone1 hitbox root")
{
	event
	{
		Subroutine;
		create_cone1_hitbox_root;
	}

	actions
	{
		Call Subroutine(destory_cone1_hitbox);
		If(Hero Of(Event Player) == Hero(Winston));
			Call Subroutine(create_cone1_hitbox_winstontesla);
		Else If(Hero Of(Event Player) == Hero(Reinhardt));
			Call Subroutine(create_cone1_hitbox_reincharge);
		Else If(Hero Of(Event Player) == Hero(Genji));
			Call Subroutine(create_cone1_hitbox_genjiblade);
		Else;
			Call Subroutine(pass);
		End;
	}
}

rule("[sub] destory cone1 hitbox")
{
	event
	{
		Subroutine;
		destory_cone1_hitbox;
	}

	actions
	{
		Event Player.temp_arr = Event Player.player_effect_id[2];
		Event Player.temp_arr2 = Event Player.player_hudtext_id[2];
		Global.global_total_effect_count -= Count Of(Event Player.temp_arr);
		Global.global_total_hudtext_count -= Count Of(Event Player.temp_arr2);
		"destroy melee effect"
		While(Event Player.temp_arr != Empty Array);
			Destroy Effect(Event Player.temp_arr[0]);
			Modify Player Variable(Event Player, temp_arr, Remove From Array By Index, 0);
			Wait(0.016, Ignore Condition);
		End;
		"destroy melee hud text"
		While(Event Player.temp_arr2 != Empty Array);
			Destroy HUD Text(Event Player.temp_arr2[0]);
			Modify Player Variable(Event Player, temp_arr2, Remove From Array By Index, 0);
			Wait(0.016, Ignore Condition);
		End;
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
		Event Player.player_effect_id[2] = Empty Array;
		Event Player.player_hudtext_id[2] = Empty Array;
	}
}

rule("[sub] [REIN] create cone1 rein charge")
{
	event
	{
		Subroutine;
		create_cone1_hitbox_reincharge;
	}

	actions
	{
		Event Player.player_cone1_dimensions = Array(2, 15);
		Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[3]], Position Of(Event Player) + Vector(0,
			Event Player.player_scale, 0), Event Player.player_cone1_dimensions[0] * Event Player.player_scale / 0.985,
			Visible To Position and Radius);
		Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
		If(Global.settings[0] == True);
			For Player Variable(Event Player, loop_j, 0, Global.settings[3], 1);
				Create Beam Effect(All Players(All Teams), Grapple Beam, Position Of(Event Player) + Vector(0, Event Player.player_scale, 0),
					Position Of(Event Player) + Vector(0, Event Player.player_scale, 0) + World Vector Of(Event Player.player_scale * Vector(
					Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
					Event Player.player_cone1_dimensions[1])) * Cosine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3]))
					+ Evaluate Once(Global.settings[4]) * Total Time Elapsed), Evaluate Once(Event Player.player_cone1_dimensions[0])
					* Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1])) * Sine From Degrees(Evaluate Once(
					Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4]) * Total Time Elapsed), Evaluate Once(
					Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(Event Player.player_cone1_dimensions[1]))),
					Event Player, Rotation), Color(White), Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				If(Global.settings[1] == True);
					Create Beam Effect(All Players(All Teams), Grapple Beam, Position Of(Event Player) + Vector(0, Event Player.player_scale, 0)
						+ World Vector Of(Event Player.player_scale * Vector(Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(
						Sine From Degrees(Event Player.player_cone1_dimensions[1])) * Cosine From Degrees(Evaluate Once(Event Player.loop_j * (
						360 / Global.settings[3])) + Evaluate Once(Global.settings[4]) * Total Time Elapsed), Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
						* Sine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
						* Total Time Elapsed), Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(
						Event Player.player_cone1_dimensions[1]))), Event Player, Rotation), Position Of(Event Player) + Vector(0,
						Event Player.player_scale, 0) + World Vector Of(Event Player.player_scale * Vector(Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
						* Cosine From Degrees(Evaluate Once((Event Player.loop_j + 1) * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
						* Total Time Elapsed), Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
						Event Player.player_cone1_dimensions[1])) * Sine From Degrees(Evaluate Once((Event Player.loop_j + 1) * (
						360 / Global.settings[3])) + Evaluate Once(Global.settings[4]) * Total Time Elapsed), Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(Event Player.player_cone1_dimensions[1]))),
						Event Player, Rotation), Color(White), Visible To Position and Radius);
					Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				End;
				Wait(0.032, Ignore Condition);
			End;
		End;
		If(Global.settings[2] == True);
			For Player Variable(Event Player, loop_j, 0, Global.settings[5], 1);
				Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[3]], Position Of(Event Player) + Vector(0,
					Event Player.player_scale, 0) + World Vector Of(Event Player.player_scale * Vector(0, 0, Evaluate Once(
					Event Player.loop_j * Event Player.player_cone1_dimensions[0]) / Evaluate Once((Global.settings[5] - 1) * Cosine From Degrees(
					Event Player.player_cone1_dimensions[1]))), Event Player, Rotation), Event Player.player_scale * Evaluate Once(
					Event Player.player_cone1_dimensions[0] * Event Player.loop_j * Tangent From Degrees(Event Player.player_cone1_dimensions[1])
					/ (Global.settings[5] - 1)) / 0.985, Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				Wait(0.032, Ignore Condition);
			End;
		End;
		"temp_arr for EFFECTS"
		Global.global_total_effect_count += Count Of(Event Player.temp_arr);
		"player_effect_id[1] for melee"
		Event Player.player_effect_id[2] = Event Player.temp_arr;
		Event Player.temp_arr = Empty Array;
	}
}

rule("[sub] [GENJI] create cone1 gengu blade")
{
	event
	{
		Subroutine;
		create_cone1_hitbox_genjiblade;
	}

	actions
	{
		Event Player.player_cone1_dimensions = Array(5, 45);
		Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[3]], Eye Position(Event Player),
			Event Player.player_cone1_dimensions[0] * Event Player.player_scale / 0.985, Visible To Position and Radius);
		Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
		If(Global.settings[0] == True);
			For Player Variable(Event Player, loop_j, 0, Global.settings[3], 1);
				Create Beam Effect(All Players(All Teams), Grapple Beam, Eye Position(Event Player), Eye Position(Event Player) + World Vector Of(
					Left, Event Player, Rotation) * Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0])
					* Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1])) * Cosine From Degrees(Evaluate Once(
					Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4]) * Total Time Elapsed)
					+ Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player) - 90)
					* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
					Event Player.player_cone1_dimensions[1])) * Sine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3]))
					+ Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Facing Direction Of(Event Player)
					* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(
					Event Player.player_cone1_dimensions[1])), Color(White), Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				If(Global.settings[1] == True);
					Create Beam Effect(All Players(All Teams), Grapple Beam, Eye Position(Event Player) + World Vector Of(Left, Event Player, Rotation)
						* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
						Event Player.player_cone1_dimensions[1])) * Cosine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3]))
						+ Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Direction From Angles(Horizontal Facing Angle Of(Event Player),
						Vertical Facing Angle Of(Event Player) - 90) * Event Player.player_scale * Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
						* Sine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
						* Total Time Elapsed) + Facing Direction Of(Event Player) * Event Player.player_scale * Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(Event Player.player_cone1_dimensions[1])),
						Eye Position(Event Player) + World Vector Of(Left, Event Player, Rotation) * Event Player.player_scale * Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
						* Cosine From Degrees(Evaluate Once((Event Player.loop_j + 1) * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
						* Total Time Elapsed) + Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player)
						- 90) * Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
						Event Player.player_cone1_dimensions[1])) * Sine From Degrees(Evaluate Once((Event Player.loop_j + 1) * (
						360 / Global.settings[3])) + Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Facing Direction Of(Event Player)
						* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(
						Event Player.player_cone1_dimensions[1])), Color(White), Visible To Position and Radius);
					Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				End;
				Wait(0.032, Ignore Condition);
			End;
		End;
		If(Global.settings[2] == True);
			For Player Variable(Event Player, loop_j, 0, Global.settings[5], 1);
				Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[3]], Eye Position(Event Player)
					+ Facing Direction Of(Event Player) * (Evaluate Once(Event Player.loop_j * Event Player.player_cone1_dimensions[0])
					* Event Player.player_scale / Evaluate Once((Global.settings[5] - 1) * Cosine From Degrees(
					Event Player.player_cone1_dimensions[1]))), Event Player.player_scale * Evaluate Once(
					Event Player.player_cone1_dimensions[0] * Event Player.loop_j * Tangent From Degrees(Event Player.player_cone1_dimensions[1])
					/ (Global.settings[5] - 1)) / 0.985, Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				Wait(0.032, Ignore Condition);
			End;
		End;
		"temp_arr for EFFECTS"
		Global.global_total_effect_count += Count Of(Event Player.temp_arr);
		"player_effect_id[1] for melee"
		Event Player.player_effect_id[2] = Event Player.temp_arr;
		Event Player.temp_arr = Empty Array;
	}
}