settings
{
	main
	{
		Description: "Melee Hitbox (MHB) Playground by pluzorminuz. Supported Abilities: All melee (excl. Flail and Torb Hammer), Blade, Charge, Tesla Cannon, Dragon, Flux, Shatter, Soundwave, Primal. Reddit: u/spadler097, Last Update: 2021 Jan 13. Discord: pluzorminuz#2542."
	}

	modes
	{
		Team Deathmatch
		{
			enabled maps
			{
				Workshop Expanse Night
			}
		}

		General
		{
			Game Mode Start: Manual
			Hero Limit: Off
			Respawn Time Scalar: 40%
		}
	}

	heroes
	{
		General
		{
			Ability Cooldown Time: 20%
			No Ammunition Requirement: On
			Spawn With Ultimate Ready: On
			Ultimate Generation: 500%
			Ultimate Generation - Combat: 500%
			Ultimate Generation - Passive: 500%

			Genji
			{
				Ultimate Duration: 400%
			}

			Winston
			{
				Ultimate Duration: 400%
			}
		}
	}

	workshop
	{
		Sphere Count: 8
	}
}

variables
{
	global:
		0: all_mhb
		1: loop_i
		2: arr_temp
		3: hero_mhb_indexmatrix
		4: mhb_dimensions
		5: global_knockback_disable
		6: global_total_effect_count
		7: global_total_hudtext_count
		8: settings
		9: color_global
		10: color_settings
		11: dragon_dimensions
		12: cam_mode_hudtext
		13: shatter_dimensions

	player:
		0: self_mhb
		1: self_mhb_temp
		2: loop_j
		3: player_hero
		4: mhb_target
		5: player_effect_colors_melee
		6: player_effect_id
		7: player_scale
		8: temp_arr
		9: temp_arr2
		10: player_hudtext_id
		11: temp_arr3
		12: player_cone1_dimensions
		13: player_dragon_t
		14: player_dragon_var
		15: player_cam_mode
		16: player_effect_visible
		17: player_flux_var
		18: player_shatter_var
		19: melee_hitbox_temp_disable
		20: player_scale_controls
		21: closest_pt
}

subroutines
{
	0: init_div
	1: create_body_mhb
	2: create_melee_hitbox_quick
	3: create_melee_hitbox_root
	4: destroy_melee_hitbox
	5: create_melee_hitbox_reinhammer
	6: pass
	7: create_cone1_hitbox_root
	8: destory_cone1_hitbox
	9: create_cone1_hitbox_offset
	10: create_cone1_hitbox_offset_lockv
	11: create_cone1_hitbox_std
	12: create_dragon_hitbox_root
	13: destroy_dragon_hitbox
	14: create_flux_hitbox_root
	15: destroy_flux_hitbox
	16: init_global_shatter_var
	17: create_shatter_hitbox_root
	18: destroy_shatter_hitbox
	19: dummy
	20: scale_up
	21: scale_down
	22: scale_stop
	23: scale_reset
	24: temparr_delete
	25: decompress_mhb_matrix
	26: create_primal_hitbox
}

disabled rule("bot scale for fun")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Has Spawned(Event Player) == True;
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		If(Random Integer(0, 1) == 0);
			Start Scaling Player(Event Player, Event Player.player_scale, True);
			Chase Player Variable At Rate(Event Player, player_scale, 4, 0.150, Destination and Rate);
		End;
	}
}

disabled rule("bot duck")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Start Holding Button(Event Player, Button(Crouch));
		Wait(5, Ignore Condition);
		Stop Holding Button(Event Player, Button(Crouch));
		Wait(5, Ignore Condition);
		Loop;
	}
}

rule("init")
{
	event
	{
		Ongoing - Global;
	}

	actions
	{
		Disable Inspector Recording;
		Call Subroutine(init_global_shatter_var);
		Global.cam_mode_hudtext = Array(Custom String("1st Person"), Custom String("3rd Person Left"), Custom String("Selected Enemy"),
			Custom String("Shatter Side"), Custom String("Shatter Top-Down"));
		"for hanzo dragon [0]r [1]center_r [2]plane_dist [3]vel [4]travel_len [5]center_display_count"
		Global.dragon_dimensions = Array(4, 2.400, 11, 12, 240, Workshop Setting Integer(Custom String("Display - Dragon"), Custom String(
			"Center Zone Sphere Count (representing the cylinder)"), 12, 8, 32, 2));
		Global.color_settings = Array(Workshop Setting Combo(Custom String("Display - Body Melee Hurtbox"), Custom String("Color"), 1,
			Array(Custom String("White"), Custom String("Green"), Custom String("Blue"), Custom String("Yellow"), Custom String("Gray"),
			Custom String("Red"), Custom String("Turquoise"), Custom String("Aqua"), Custom String("Rose")), 0), Workshop Setting Combo(
			Custom String("Display - Melee Hitbox"), Custom String("Idle Color"), 2, Array(Custom String("White"), Custom String("Green"),
			Custom String("Blue"), Custom String("Yellow"), Custom String("Gray"), Custom String("Red"), Custom String("Turquoise"),
			Custom String("Aqua"), Custom String("Rose")), 0), Workshop Setting Combo(Custom String("Display - Melee Hitbox"),
			Custom String("Active Color"), 3, Array(Custom String("White"), Custom String("Green"), Custom String("Blue"), Custom String(
			"Yellow"), Custom String("Gray"), Custom String("Red"), Custom String("Turquoise"), Custom String("Aqua"), Custom String(
			"Rose")), 1), Workshop Setting Combo(Custom String("Display - Cone"), Custom String("Cone Color"), 4, Array(Custom String(
			"White"), Custom String("Green"), Custom String("Blue"), Custom String("Yellow"), Custom String("Gray"), Custom String("Red"),
			Custom String("Turquoise"), Custom String("Aqua"), Custom String("Rose")), 7), Workshop Setting Combo(Custom String(
			"Display - Dragon"), Custom String("Body Color (150dps zone)"), 2, Array(Custom String("White"), Custom String("Green"),
			Custom String("Blue"), Custom String("Yellow"), Custom String("Gray"), Custom String("Red"), Custom String("Turquoise"),
			Custom String("Aqua"), Custom String("Rose")), 0), Workshop Setting Combo(Custom String("Display - Dragon"), Custom String(
			"Center Color (300dps zone)"), 5, Array(Custom String("White"), Custom String("Green"), Custom String("Blue"), Custom String(
			"Yellow"), Custom String("Gray"), Custom String("Red"), Custom String("Turquoise"), Custom String("Aqua"), Custom String(
			"Rose")), 1), Workshop Setting Combo(Custom String("Display - Flux"), Custom String("Flux Color"), 6, Array(Custom String(
			"White"), Custom String("Green"), Custom String("Blue"), Custom String("Yellow"), Custom String("Gray"), Custom String("Red"),
			Custom String("Turquoise"), Custom String("Aqua"), Custom String("Rose")), 0), Workshop Setting Combo(Custom String(
			"Display - Earthshatter"), Custom String("Shatter Color"), 7, Array(Custom String("White"), Custom String("Green"),
			Custom String("Blue"), Custom String("Yellow"), Custom String("Gray"), Custom String("Red"), Custom String("Turquoise"),
			Custom String("Aqua"), Custom String("Rose")), 0));
		Global.color_global = Array(Color(White), Color(Green), Color(Blue), Color(Yellow), Color(Gray), Color(Red), Color(Turquoise),
			Color(Aqua), Color(Rose));
		Global.settings = Array(Workshop Setting Toggle(Custom String("Display - Cone"), Custom String("Use Beams"), True, 0),
			Workshop Setting Toggle(Custom String("Display - Cone"), Custom String("Show Circle (lag warning!!!)"), False, 1),
			Workshop Setting Toggle(Custom String("Display - Cone"), Custom String("Use Spheres"), False, 3), Workshop Setting Integer(
			Custom String("Display - Cone"), Custom String("Beam Count"), 6, 4, 16, 2), Workshop Setting Integer(Custom String(
			"Display - Cone"), Custom String("Animation Speed (deg/s)"), 30, 1, 360, 5), Workshop Setting Integer(Custom String(
			"Display - Cone"), Custom String("Sphere Count"), 12, 4, 32, 4));
		Global.global_knockback_disable = Workshop Setting Toggle(Custom String("Global"), Custom String("Disable Knockback?"), True, 0);
		"melee hitbox dimensions [0]r [1]dist_from_eye"
		Global.mhb_dimensions = Array(1, 1.500);
		Global.hero_mhb_indexmatrix = Array(Array(0, 0, 0), Array(0, 6, 0), Array(0, 0, 0), Array(0, 0, 0), Array(0, 5, 0), Array(1, 1, 1),
			Array(0, 0, 0), Array(1, 2, 1), Array(0, 0, 0), Array(1, 1, 1), Array(0, 0, 0), Array(0, 0, 0), Array(0, 0, 0), Array(1, 1, 1),
			Array(0, 0, 0), Array(0, 0, 0), Array(0, 0, 0), Array(0, 0, 0), Array(0, 0, 0), Array(1, 0, 1), Array(0, 3, 0), Array(0, 4, 0),
			Array(1, 1, 1), Array(0, 0, 0), Array(1, 1, 1), Array(0, 0, 0), Array(0, 0, 0), Array(2, 0, 3), Array(0, 0, 0), Array(0, 0, 0),
			Array(0, 0, 0), Array(1, 2, 2));
		Global.all_mhb = Empty Array;
		Global.arr_temp = Empty Array;
		"mhb radius"
		disabled Global.arr_temp = Array(500, 699.707, 949.707);
		"mhb radius 2"
		Global.arr_temp = Array(500, 700, 950);
		Call Subroutine(init_div);
		Global.all_mhb[0] = Global.arr_temp;
		"mhb standing height"
		disabled Global.arr_temp = Array(1999.020, 2298.830, 2499.020, 1968.750, 1885.740, 1548.830, 1992.190);
		"mhb standing height 2"
		Global.arr_temp = Array(2000, 2300, 2500, 1968.750, 2000, 1548.830, 1993);
		Call Subroutine(init_div);
		Global.all_mhb[1] = Global.arr_temp;
		"mhb ducking height"
		disabled Global.arr_temp = Array(1298.830, 1718.750, 2048.830, 1999.020);
		"mhb ducking height"
		Global.arr_temp = Array(1298.830, 1718.750, 2048.830, 1999.020);
		Call Subroutine(init_div);
		Global.all_mhb[2] = Global.arr_temp;
		Global.arr_temp = Empty Array;
		Create HUD Text(All Players(All Teams), Custom String("Code: YASRJ"), Custom String("The MHB Playground (210113)"), Custom String(
			"by pluzorminuz"), Top, 1, Color(Yellow), Color(White), Color(Aqua), Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, String("{0} {1}", Custom String("effect count"),
			Global.global_total_effect_count), Right, -999, Color(White), Color(White), Color(Gray), Visible To and String,
			Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, String("{0} {1}", Custom String("hud text count"),
			Global.global_total_hudtext_count), Right, -998, Color(Gray), Color(White), Color(Gray), Visible To and String,
			Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, String("{0} {1} {2}", Server Load, Server Load Average, Server Load Peak),
			Right, -1000, Color(White), Color(White), Color(Yellow), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Custom String("Hitbox Legend"), Null, Null, Right, -500, Color(White), Color(White), Color(
			Yellow), Visible To and String, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("[ACKNOWLEDGE] Switch Hero"), Left, -99, Color(White), Color(
			White), Color(White), Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("[Group Up] Toggle Melee hitbox"), Left, -98, Color(White),
			Color(White), Color(White), Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("[Jump + Crouch] Reset Scale"), Left, -95, Color(White), Color(
			White), Color(White), Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("[Interact + Jump + Crouch] Reset Bot Scale"), Left, -94, Color(
			White), Color(White), Color(White), Visible To, Default Visibility);
		Create HUD Text(All Players(All Teams), Null, Null, Custom String("[Hello] Teleport Bot to self"), Left, -93, Color(White), Color(
			White), Color(White), Visible To, Default Visibility);
		Global.global_total_hudtext_count += 10;
		Wait(1, Ignore Condition);
		Call Subroutine(dummy);
	}
}

rule("Dummy Bot Test")
{
	event
	{
		Subroutine;
		dummy;
	}

	actions
	{
		disabled Create Dummy Bot(Random Value In Array(All Heroes), Team 2, -1, Vector(0, -1000, 0), Vector(0, 0, 0));
		disabled Create Dummy Bot(Hero(Reinhardt), Team 2, -1, Vector(0, -1000, 0), Vector(0, 0, 0));
		Create Dummy Bot(Random Value In Array(All Tank Heroes), Team 2, -1, Vector(0, -1000, 0), Vector(0, 0, 0));
		Create Dummy Bot(Random Value In Array(All Support Heroes), Team 2, -1, Vector(0, -1000, 0), Vector(0, 0, 0));
		Create Dummy Bot(Random Value In Array(All Damage Heroes), Team 2, -1, Vector(0, -1000, 0), Vector(0, 0, 0));
	}
}

rule("player_init_once")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
		Event Player.temp_arr3 = Empty Array;
		Event Player.player_effect_id = Empty Array;
		Event Player.player_hudtext_id = Empty Array;
		Event Player.player_scale = 1;
		"for hanzo dragon. [0]arrow_ro [1]arrow_rd [2]arrow_ro_temp [3]arrow_rd_temp"
		Event Player.player_dragon_var = Array(Vector(0, -1000, 0), Down, Vector(0, -1000, 0), Down, Vector(0, 0, 0));
		Call Subroutine(create_body_mhb);
		disabled Wait(2, Ignore Condition);
		disabled Start Scaling Player(Event Player, Event Player.player_scale, True);
		disabled Chase Player Variable At Rate(Event Player, player_scale, 15, 1, Destination and Rate);
	}
}

rule("player_change_hero_init")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.player_hero != Hero Of(Event Player);
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.melee_hitbox_temp_disable = 0;
		Event Player.player_hero = Hero Of(Event Player);
		Event Player.self_mhb_temp = Global.hero_mhb_indexmatrix[Index Of Array Value(All Heroes, Hero Of(Event Player))];
		Call Subroutine(decompress_mhb_matrix);
		Wait(0.016, Ignore Condition);
		Call Subroutine(create_melee_hitbox_root);
		Wait(0.016, Ignore Condition);
		Call Subroutine(create_cone1_hitbox_root);
		Wait(0.016, Ignore Condition);
		Call Subroutine(create_dragon_hitbox_root);
		Wait(0.016, Ignore Condition);
		Call Subroutine(create_flux_hitbox_root);
		Wait(0.016, Ignore Condition);
		Call Subroutine(create_shatter_hitbox_root);
	}
}

rule("[sub] decompress mhb matrix")
{
	event
	{
		Subroutine;
		decompress_mhb_matrix;
	}

	actions
	{
		For Player Variable(Event Player, loop_j, 0, Count Of(Event Player.self_mhb_temp), 1);
			Event Player.self_mhb_temp[Event Player.loop_j] = Global.all_mhb[Event Player.loop_j][Event Player.self_mhb_temp[Event Player.loop_j]];
		End;
		Event Player.self_mhb = Array(Event Player.self_mhb_temp[0], Vector(0, Event Player.self_mhb_temp[0], 0), Vector(0,
			Event Player.self_mhb_temp[1] - Event Player.self_mhb_temp[0], 0), Null, Vector(0,
			Event Player.self_mhb_temp[1] - Event Player.self_mhb_temp[0], 0), Vector(0,
			Event Player.self_mhb_temp[2] - Event Player.self_mhb_temp[0], 0));
		Event Player.self_mhb[3] = Event Player.self_mhb[2] - Event Player.self_mhb[1];
	}
}

rule("player_no_knockback")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Global.global_knockback_disable == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Set Knockback Dealt(Event Player, 0);
		Set Knockback Received(Event Player, 0);
	}
}

rule("player_crouch_true_mhb_switch")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Crouching(Event Player) == True;
	}

	actions
	{
		Event Player.self_mhb[2] = Event Player.self_mhb[5];
		Event Player.self_mhb[3] = Event Player.self_mhb[2] - Event Player.self_mhb[1];
	}
}

rule("player_crouch_false_mhb_switch")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Crouching(Event Player) == False;
	}

	actions
	{
		Event Player.self_mhb[2] = Event Player.self_mhb[4];
		Event Player.self_mhb[3] = Event Player.self_mhb[2] - Event Player.self_mhb[1];
	}
}

rule("kill self")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Acknowledge) == True;
	}

	actions
	{
		Kill(Event Player, Null);
	}
}

rule("[sub] divide init array")
{
	event
	{
		Subroutine;
		init_div;
	}

	actions
	{
		For Global Variable(loop_i, 0, Count Of(Global.arr_temp), 1);
			Global.arr_temp[Global.loop_i] /= 1000;
		End;
	}
}

rule("select_player_near_crosshair_mhb_target")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Interact)) == True;
	}

	actions
	{
		Event Player.mhb_target = Player Closest To Reticle(Event Player, Opposite Team Of(Team Of(Event Player)));
	}
}

rule("damage_indicator_melee")
{
	event
	{
		Player Dealt Damage;
		All;
		All;
	}

	actions
	{
		Small Message(Event Player, String("{0} {1} {2}", Custom String("damaged"), Victim, Event Damage));
	}
}

rule("melee change melee_hitbox color")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Meleeing(Event Player) == True;
	}

	actions
	{
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[2]];
		Wait(0.176, Ignore Condition);
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[1]];
	}
}

rule("bot_shield")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Dummy Bot(Event Player) == True;
	}

	actions
	{
		Add Health Pool To Player(Event Player, Shields, 3000, True, True);
	}
}

rule("[sub] all hero body melee hurtbox")
{
	event
	{
		Subroutine;
		create_body_mhb;
	}

	actions
	{
		"create melee hurtbox"
		For Player Variable(Event Player, loop_j, 0, 4, 1);
			Create Effect(All Players(Opposite Team Of(Team Of(Event Player))), Sphere, Global.color_global[Global.color_settings[0]],
				Update Every Frame(Position Of(Event Player) + Event Player.player_scale * (Evaluate Once(1 - Event Player.loop_j / 3)
				* Event Player.self_mhb[1] + Evaluate Once(Event Player.loop_j / 3) * Event Player.self_mhb[2])),
				Event Player.player_scale * Event Player.self_mhb[0] / 0.985, Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
		"end create melee hurtbox"
		End;
		"no need to create hud text for dummies"
		If(Is Dummy Bot(Event Player) != True);
			Create HUD Text(All Players(All Teams), String("{0} {1} {2}", Custom String("Melee Hurtbox of"), Hero Icon String(Hero Of(
				Event Player)), Custom String("Capsule")), Null, Null, Right, -499, Global.color_global[Global.color_settings[0]], Color(
				White), Color(White), Visible To and String, Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			"mhb looking at"
			Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("Looking at"), Player Closest To Reticle(Event Player,
				Opposite Team Of(Team Of(Event Player))), Hero Icon String(Hero Of(Player Closest To Reticle(Event Player, Opposite Team Of(
				Team Of(Event Player)))))), Null, Null, Left, 0, Color(White), Color(White), Color(White), String, Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			"mhb selected target"
			Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("[Interact] Selected"), Event Player.mhb_target,
				Hero Icon String(Hero Of(Event Player.mhb_target))), Null, Null, Left, 1, Global.color_global[Global.color_settings[1]], Color(
				White), Color(White), String, Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			"reload camera mode"
			Create HUD Text(Event Player, Null, Null, String("{0}: {1}", Custom String("[RELOAD] Camera Mode"),
				Global.cam_mode_hudtext[Event Player.player_cam_mode]), Left, -100, Color(White), Color(White), Color(White), String,
				Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			"player scale"
			Create HUD Text(Event Player, Null, Null, String("{0}: {1}", Custom String("[HOLD Jump / Crouch] Player Scale"),
				Event Player.player_scale), Left, -97, Color(White), Color(White), Color(White), String, Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			"selected player scale, can only modify bots scale"
			Create HUD Text(Event Player, Null, Null, String("{0}: {1}", Custom String("[HOLD Interact + Jump / Crouch] Bot Scale"),
				Event Player.mhb_target.player_scale), Left, -96, Color(White), Color(White), Color(White), String, Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
		End;
		"temp_arr for EFFECTS"
		Global.global_total_effect_count += Count Of(Event Player.temp_arr);
		"temp_arr2 for HUD TEXT"
		Global.global_total_hudtext_count += Count Of(Event Player.temp_arr2);
		"player_effect_id[0] for mhb body"
		Event Player.player_effect_id[0] = Event Player.temp_arr;
		Event Player.player_hudtext_id[0] = Event Player.temp_arr2;
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
	}
}

rule("[sub] create melee hitbox quick + hud")
{
	event
	{
		Subroutine;
		create_melee_hitbox_quick;
	}

	actions
	{
		"no need to create hud text for dummies"
		If(Is Dummy Bot(Event Player) != True);
			Create HUD Text(Event Player, String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Melee)), Custom String(
				"Sphere")), Null, Null, Right, -498, Event Player.player_effect_colors_melee[0], Color(White), Color(White), String and Color,
				Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			"melee predict"
			Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("Melee Distance"), 100 * (Distance Between(Eye Position(
				Event Player) + Global.mhb_dimensions[1] * Event Player.player_scale * Facing Direction Of(Event Player), Position Of(
				Event Player.mhb_target) + Event Player.mhb_target.self_mhb[1] * Event Player.mhb_target.player_scale + Min(Max(Dot Product(
				Eye Position(Event Player) + Global.mhb_dimensions[1] * Event Player.player_scale * Facing Direction Of(Event Player)
				- Position Of(Event Player.mhb_target) - Event Player.mhb_target.self_mhb[1] * Event Player.mhb_target.player_scale,
				Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale) / Dot Product(
				Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale,
				Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale), 0), 1)
				* Event Player.mhb_target.player_scale * Event Player.mhb_target.self_mhb[3])
				- Event Player.mhb_target.self_mhb[0] * Event Player.mhb_target.player_scale - Global.mhb_dimensions[0] * Event Player.player_scale),
				Custom String("cm")), Null, Null, Left, 2, Global.color_global[Global.color_settings[2]], Color(White), Color(White), String,
				Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
		End;
		"melee hitbox color"
		Event Player.player_effect_colors_melee = Array(Global.color_global[Global.color_settings[1]]);
		"create melee hitbox"
		Create Effect(All Players(All Teams), Sphere, Event Player.player_effect_colors_melee[0], Update Every Frame(Eye Position(
			Event Player) + Global.mhb_dimensions[1] * Facing Direction Of(Event Player) * Event Player.player_scale),
			Event Player.player_scale * Global.mhb_dimensions[0] / 0.985, Visible To Position Radius and Color);
		Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
		disabled Event Player.player_effect_id[1] = Array(Event Player.temp_arr);
		"temp_arr for EFFECTS"
		Global.global_total_effect_count += Count Of(Event Player.temp_arr);
		"temp_arr2 for HUD TEXT"
		Global.global_total_hudtext_count += Count Of(Event Player.temp_arr2);
		"player_effect_id[1] for melee"
		Modify Player Variable At Index(Event Player, player_effect_id, 1, Append To Array, Event Player.temp_arr);
		Modify Player Variable At Index(Event Player, player_hudtext_id, 1, Append To Array, Event Player.temp_arr2);
		disabled Event Player.player_effect_id[1] = Event Player.temp_arr;
		disabled Event Player.player_hudtext_id[1] = Event Player.temp_arr2;
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
	}
}

rule("[sub] create melee hitbox root")
{
	event
	{
		Subroutine;
		create_melee_hitbox_root;
	}

	actions
	{
		Call Subroutine(destroy_melee_hitbox);
		If(Hero Of(Event Player) == Hero(Reinhardt));
			Call Subroutine(create_melee_hitbox_reinhammer);
		Else If(Hero Of(Event Player) == Hero(Brigitte));
			Call Subroutine(pass);
		Else;
			Call Subroutine(create_melee_hitbox_quick);
		End;
	}
}

rule("[sub] destory melee hitbox")
{
	event
	{
		Subroutine;
		destroy_melee_hitbox;
	}

	actions
	{
		Event Player.temp_arr = Event Player.player_effect_id[1];
		Event Player.temp_arr2 = Event Player.player_hudtext_id[1];
		Event Player.player_effect_id[1] = Empty Array;
		Event Player.player_hudtext_id[1] = Empty Array;
		Call Subroutine(temparr_delete);
	}
}

rule("[sub] create melee hitbox rein hammer")
{
	event
	{
		Subroutine;
		create_melee_hitbox_reinhammer;
	}

	actions
	{
		"no need to create hud text for dummies"
		If(Is Dummy Bot(Event Player) != True);
			Create HUD Text(Event Player, String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Primary Fire)), Custom String(
				"Moving Spheres")), Null, Null, Right, -498, Event Player.player_effect_colors_melee[12], Color(White), Color(White),
				String and Color, Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
		End;
		"rein hammer hitbox color"
		Event Player.player_effect_colors_melee = Array(Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]]);
		"rein hammer data"
		Event Player.temp_arr3 = Array(Vector(-2, -0.300, 3), Vector(-0.920, -0.300, 3), Vector(-0.280, -0.300, 3), Vector(0.360, -0.300,
			3), Vector(1, -0.300, 3), Vector(1.640, -0.300, 3), Vector(2, -0.300, 3), Vector(1.200, -0.300, 3), Vector(0.560, -0.300, 3),
			Vector(-0.080, -0.300, 3), Vector(-0.720, -0.300, 3), Vector(-1.360, -0.300, 3));
		"create rein hammer hitbox"
		For Player Variable(Event Player, loop_j, 0, Count Of(Event Player.temp_arr3), 1);
			Create Effect(All Players(All Teams), Sphere, Event Player.player_effect_colors_melee[Evaluate Once(Event Player.loop_j)],
				Eye Position(Event Player) + Event Player.player_scale * (World Vector Of(Left, Event Player, Rotation) * Evaluate Once(
				X Component Of(Event Player.temp_arr3[Event Player.loop_j])) + Direction From Angles(Horizontal Facing Angle Of(Event Player),
				Vertical Facing Angle Of(Event Player) - 90) * Evaluate Once(Y Component Of(Event Player.temp_arr3[Event Player.loop_j]))
				+ Facing Direction Of(Event Player) * Evaluate Once(Z Component Of(Event Player.temp_arr3[Event Player.loop_j]))),
				1 * Event Player.player_scale / 0.985, Visible To Position Radius and Color);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			Create Effect(All Players(All Teams), Sphere, Event Player.player_effect_colors_melee[Evaluate Once(Event Player.loop_j)],
				Eye Position(Event Player) + Event Player.player_scale * (World Vector Of(Left, Event Player, Rotation) * Evaluate Once(
				X Component Of(Event Player.temp_arr3[Event Player.loop_j]) / 2) + Direction From Angles(Horizontal Facing Angle Of(
				Event Player), Vertical Facing Angle Of(Event Player) - 90) * Evaluate Once(Y Component Of(
				Event Player.temp_arr3[Event Player.loop_j]) / 2) + Facing Direction Of(Event Player) * Evaluate Once(Z Component Of(
				Event Player.temp_arr3[Event Player.loop_j]) / 2)), 0.500 * Event Player.player_scale / 0.985,
				Visible To Position Radius and Color);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			Wait(0.016, Ignore Condition);
		End;
		"temp_arr for EFFECTS"
		Global.global_total_effect_count += Count Of(Event Player.temp_arr);
		"temp_arr2 for HUD TEXT"
		Global.global_total_hudtext_count += Count Of(Event Player.temp_arr2);
		"player_effect_id[1] for melee"
		Modify Player Variable At Index(Event Player, player_effect_id, 1, Append To Array, Event Player.temp_arr);
		Modify Player Variable At Index(Event Player, player_hudtext_id, 1, Append To Array, Event Player.temp_arr2);
		disabled Event Player.player_effect_id[1] = Event Player.temp_arr;
		disabled Event Player.player_hudtext_id[1] = Event Player.temp_arr2;
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
		Event Player.temp_arr3 = Empty Array;
	}
}

rule("[sub] nothing")
{
	event
	{
		Subroutine;
		pass;
	}
}

rule("[REIN] rein_hammer_swing_change_color")
{
	event
	{
		Ongoing - Each Player;
		All;
		Reinhardt;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
	}

	actions
	{
		Wait(0.432, Ignore Condition);
		Event Player.player_effect_colors_melee[12] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[2]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[1] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[2] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[1] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[3] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[2] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[4] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[3] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[5] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[4] = Global.color_global[Global.color_settings[1]];
		"33"
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[6] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[5] = Global.color_global[Global.color_settings[1]];
		Wait(0.416, Ignore Condition);
		Event Player.player_effect_colors_melee[6] = Global.color_global[Global.color_settings[1]];
		Wait(0.064, Ignore Condition);
		Abort If Condition Is False;
		Wait(0.352, Ignore Condition);
		Event Player.player_effect_colors_melee[6] = Global.color_global[Global.color_settings[2]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[7] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[6] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[8] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[7] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[9] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[8] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[10] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[9] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[11] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[10] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[11] = Global.color_global[Global.color_settings[1]];
		Wait(0.256, Ignore Condition);
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[1]];
		Wait(0.192, Ignore Condition);
		Loop If Condition Is True;
	}
}

rule("[REIN] rein_hammer_swing_change_color_off")
{
	event
	{
		Ongoing - Each Player;
		All;
		Reinhardt;
	}

	conditions
	{
		Is Firing Primary(Event Player) != True;
	}

	actions
	{
		Event Player.player_effect_colors_melee[12] = Global.color_global[Global.color_settings[1]];
	}
}

rule("[sub] create cone1 hitbox root")
{
	event
	{
		Subroutine;
		create_cone1_hitbox_root;
	}

	actions
	{
		Call Subroutine(destory_cone1_hitbox);
		If(Hero Of(Event Player) == Hero(Winston));
			Event Player.player_cone1_dimensions = Array(8, 20);
			Call Subroutine(create_cone1_hitbox_offset);
			"no need to create hud text for dummies"
			If(Is Dummy Bot(Event Player) != True);
				Create HUD Text(Event Player, String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Primary Fire)), Custom String(
					"Cone")), Null, Null, Right, -497, Global.color_global[Global.color_settings[3]], Color(White), Color(White), String and Color,
					Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			End;
		Else If(Hero Of(Event Player) == Hero(Reinhardt));
			Event Player.player_cone1_dimensions = Array(2, 15);
			Call Subroutine(create_cone1_hitbox_offset_lockv);
			If(Is Dummy Bot(Event Player) != True);
				Create HUD Text(Event Player, String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ability 1)), Custom String(
					"Cone")), Null, Null, Right, -497, Global.color_global[Global.color_settings[3]], Color(White), Color(White), String and Color,
					Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			End;
		Else If(Hero Of(Event Player) == Hero(Genji));
			Event Player.player_cone1_dimensions = Array(5, 45);
			Call Subroutine(create_cone1_hitbox_std);
			If(Is Dummy Bot(Event Player) != True);
				Create HUD Text(Event Player, String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ultimate)), Custom String(
					"Cone")), Null, Null, Right, -497, Global.color_global[Global.color_settings[3]], Color(White), Color(White), String and Color,
					Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			End;
		Else If(Hero Of(Event Player) == Hero(LÃºcio));
			Event Player.player_cone1_dimensions = Array(7, 35);
			Call Subroutine(create_cone1_hitbox_std);
			If(Is Dummy Bot(Event Player) != True);
				Create HUD Text(Event Player, String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Secondary Fire)), Custom String(
					"Cone")), Null, Null, Right, -497, Global.color_global[Global.color_settings[3]], Color(White), Color(White), String and Color,
					Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			End;
		Else;
			Call Subroutine(pass);
		End;
		Global.global_total_effect_count += Count Of(Event Player.temp_arr);
		Global.global_total_hudtext_count += Count Of(Event Player.temp_arr2);
		"player_effect_id[2] for cone1"
		Event Player.player_effect_id[2] = Event Player.temp_arr;
		Event Player.player_hudtext_id[2] = Event Player.temp_arr2;
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
	}
}

rule("[sub] destory cone1 hitbox")
{
	event
	{
		Subroutine;
		destory_cone1_hitbox;
	}

	actions
	{
		Event Player.temp_arr = Event Player.player_effect_id[2];
		Event Player.temp_arr2 = Event Player.player_hudtext_id[2];
		Event Player.player_effect_id[2] = Empty Array;
		Event Player.player_hudtext_id[2] = Empty Array;
		Call Subroutine(temparr_delete);
	}
}

rule("[sub] create_cone1_offset (offset 0,k,0)")
{
	event
	{
		Subroutine;
		create_cone1_hitbox_offset;
	}

	actions
	{
		Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[3]], Position Of(Event Player) + Vector(0,
			Event Player.player_scale, 0), Event Player.player_cone1_dimensions[0] * Event Player.player_scale / 0.985,
			Visible To Position and Radius);
		Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
		If(Global.settings[0] == True);
			For Player Variable(Event Player, loop_j, 0, Global.settings[3], 1);
				Create Beam Effect(All Players(All Teams), Grapple Beam, Position Of(Event Player) + Vector(0, Event Player.player_scale, 0),
					Position Of(Event Player) + Vector(0, Event Player.player_scale, 0) + World Vector Of(Left, Event Player, Rotation)
					* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
					Event Player.player_cone1_dimensions[1])) * Cosine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3]))
					+ Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Direction From Angles(Horizontal Facing Angle Of(Event Player),
					Vertical Facing Angle Of(Event Player) - 90) * Event Player.player_scale * Evaluate Once(
					Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
					* Sine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
					* Total Time Elapsed) + Facing Direction Of(Event Player) * Event Player.player_scale * Evaluate Once(
					Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(Event Player.player_cone1_dimensions[1])), Color(
					White), Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				If(Global.settings[1] == True);
					Create Beam Effect(All Players(All Teams), Grapple Beam, Position Of(Event Player) + Vector(0, Event Player.player_scale, 0)
						+ World Vector Of(Left, Event Player, Rotation) * Event Player.player_scale * Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
						* Cosine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
						* Total Time Elapsed) + Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player)
						- 90) * Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
						Event Player.player_cone1_dimensions[1])) * Sine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3]))
						+ Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Facing Direction Of(Event Player)
						* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(
						Event Player.player_cone1_dimensions[1])), Position Of(Event Player) + Vector(0, Event Player.player_scale, 0)
						+ World Vector Of(Left, Event Player, Rotation) * Event Player.player_scale * Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
						* Cosine From Degrees(Evaluate Once((Event Player.loop_j + 1) * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
						* Total Time Elapsed) + Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player)
						- 90) * Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
						Event Player.player_cone1_dimensions[1])) * Sine From Degrees(Evaluate Once((Event Player.loop_j + 1) * (
						360 / Global.settings[3])) + Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Facing Direction Of(Event Player)
						* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(
						Event Player.player_cone1_dimensions[1])), Color(White), Visible To Position and Radius);
					Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				End;
				Wait(0.032, Ignore Condition);
			End;
		End;
		If(Global.settings[2] == True);
			For Player Variable(Event Player, loop_j, 0, Global.settings[5], 1);
				Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[3]], Position Of(Event Player) + Vector(0,
					Event Player.player_scale, 0) + Facing Direction Of(Event Player) * (Evaluate Once(
					Event Player.loop_j * Event Player.player_cone1_dimensions[0]) * Event Player.player_scale / Evaluate Once((
					Global.settings[5] - 1) * Cosine From Degrees(Event Player.player_cone1_dimensions[1]))),
					Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0] * Event Player.loop_j * Tangent From Degrees(
					Event Player.player_cone1_dimensions[1]) / (Global.settings[5] - 1)) / 0.985, Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				Wait(0.032, Ignore Condition);
			End;
		End;
	}
}

rule("[sub] create_cone1_offset_novert (offset 0,k,0)")
{
	event
	{
		Subroutine;
		create_cone1_hitbox_offset_lockv;
	}

	actions
	{
		Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[3]], Position Of(Event Player) + Vector(0,
			Event Player.player_scale, 0), Event Player.player_cone1_dimensions[0] * Event Player.player_scale / 0.985,
			Visible To Position and Radius);
		Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
		If(Global.settings[0] == True);
			For Player Variable(Event Player, loop_j, 0, Global.settings[3], 1);
				Create Beam Effect(All Players(All Teams), Grapple Beam, Position Of(Event Player) + Vector(0, Event Player.player_scale, 0),
					Position Of(Event Player) + Vector(0, Event Player.player_scale, 0) + World Vector Of(Event Player.player_scale * Vector(
					Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
					Event Player.player_cone1_dimensions[1])) * Cosine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3]))
					+ Evaluate Once(Global.settings[4]) * Total Time Elapsed), Evaluate Once(Event Player.player_cone1_dimensions[0])
					* Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1])) * Sine From Degrees(Evaluate Once(
					Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4]) * Total Time Elapsed), Evaluate Once(
					Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(Event Player.player_cone1_dimensions[1]))),
					Event Player, Rotation), Color(White), Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				If(Global.settings[1] == True);
					Create Beam Effect(All Players(All Teams), Grapple Beam, Position Of(Event Player) + Vector(0, Event Player.player_scale, 0)
						+ World Vector Of(Event Player.player_scale * Vector(Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(
						Sine From Degrees(Event Player.player_cone1_dimensions[1])) * Cosine From Degrees(Evaluate Once(Event Player.loop_j * (
						360 / Global.settings[3])) + Evaluate Once(Global.settings[4]) * Total Time Elapsed), Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
						* Sine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
						* Total Time Elapsed), Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(
						Event Player.player_cone1_dimensions[1]))), Event Player, Rotation), Position Of(Event Player) + Vector(0,
						Event Player.player_scale, 0) + World Vector Of(Event Player.player_scale * Vector(Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
						* Cosine From Degrees(Evaluate Once((Event Player.loop_j + 1) * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
						* Total Time Elapsed), Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
						Event Player.player_cone1_dimensions[1])) * Sine From Degrees(Evaluate Once((Event Player.loop_j + 1) * (
						360 / Global.settings[3])) + Evaluate Once(Global.settings[4]) * Total Time Elapsed), Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(Event Player.player_cone1_dimensions[1]))),
						Event Player, Rotation), Color(White), Visible To Position and Radius);
					Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				End;
				Wait(0.032, Ignore Condition);
			End;
		End;
		If(Global.settings[2] == True);
			For Player Variable(Event Player, loop_j, 0, Global.settings[5], 1);
				Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[3]], Position Of(Event Player) + Vector(0,
					Event Player.player_scale, 0) + World Vector Of(Event Player.player_scale * Vector(0, 0, Evaluate Once(
					Event Player.loop_j * Event Player.player_cone1_dimensions[0]) / Evaluate Once((Global.settings[5] - 1) * Cosine From Degrees(
					Event Player.player_cone1_dimensions[1]))), Event Player, Rotation), Event Player.player_scale * Evaluate Once(
					Event Player.player_cone1_dimensions[0] * Event Player.loop_j * Tangent From Degrees(Event Player.player_cone1_dimensions[1])
					/ (Global.settings[5] - 1)) / 0.985, Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				Wait(0.032, Ignore Condition);
			End;
		End;
	}
}

rule("[sub] create_cone1_standard (origin at eye)")
{
	event
	{
		Subroutine;
		create_cone1_hitbox_std;
	}

	actions
	{
		Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[3]], Eye Position(Event Player),
			Event Player.player_cone1_dimensions[0] * Event Player.player_scale / 0.985, Visible To Position and Radius);
		Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
		If(Global.settings[0] == True);
			For Player Variable(Event Player, loop_j, 0, Global.settings[3], 1);
				Create Beam Effect(All Players(All Teams), Grapple Beam, Eye Position(Event Player) + World Vector Of(Left, Event Player, Rotation)
					* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0] * 0.100) * Evaluate Once(Sine From Degrees(
					Event Player.player_cone1_dimensions[1])) * Cosine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3]))
					+ Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Direction From Angles(Horizontal Facing Angle Of(Event Player),
					Vertical Facing Angle Of(Event Player) - 90) * Event Player.player_scale * Evaluate Once(
					Event Player.player_cone1_dimensions[0] * 0.100) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
					* Sine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
					* Total Time Elapsed) + Facing Direction Of(Event Player) * Event Player.player_scale * Evaluate Once(
					Event Player.player_cone1_dimensions[0] * 0.100) * Evaluate Once(Cosine From Degrees(Event Player.player_cone1_dimensions[1])),
					Eye Position(Event Player) + World Vector Of(Left, Event Player, Rotation) * Event Player.player_scale * Evaluate Once(
					Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
					* Cosine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
					* Total Time Elapsed) + Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player)
					- 90) * Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
					Event Player.player_cone1_dimensions[1])) * Sine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3]))
					+ Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Facing Direction Of(Event Player)
					* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(
					Event Player.player_cone1_dimensions[1])), Color(White), Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				If(Global.settings[1] == True);
					Create Beam Effect(All Players(All Teams), Grapple Beam, Eye Position(Event Player) + World Vector Of(Left, Event Player, Rotation)
						* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
						Event Player.player_cone1_dimensions[1])) * Cosine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3]))
						+ Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Direction From Angles(Horizontal Facing Angle Of(Event Player),
						Vertical Facing Angle Of(Event Player) - 90) * Event Player.player_scale * Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
						* Sine From Degrees(Evaluate Once(Event Player.loop_j * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
						* Total Time Elapsed) + Facing Direction Of(Event Player) * Event Player.player_scale * Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(Event Player.player_cone1_dimensions[1])),
						Eye Position(Event Player) + World Vector Of(Left, Event Player, Rotation) * Event Player.player_scale * Evaluate Once(
						Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(Event Player.player_cone1_dimensions[1]))
						* Cosine From Degrees(Evaluate Once((Event Player.loop_j + 1) * (360 / Global.settings[3])) + Evaluate Once(Global.settings[4])
						* Total Time Elapsed) + Direction From Angles(Horizontal Facing Angle Of(Event Player), Vertical Facing Angle Of(Event Player)
						- 90) * Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Sine From Degrees(
						Event Player.player_cone1_dimensions[1])) * Sine From Degrees(Evaluate Once((Event Player.loop_j + 1) * (
						360 / Global.settings[3])) + Evaluate Once(Global.settings[4]) * Total Time Elapsed) + Facing Direction Of(Event Player)
						* Event Player.player_scale * Evaluate Once(Event Player.player_cone1_dimensions[0]) * Evaluate Once(Cosine From Degrees(
						Event Player.player_cone1_dimensions[1])), Color(White), Visible To Position and Radius);
					Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				End;
				Wait(0.032, Ignore Condition);
			End;
		End;
		If(Global.settings[2] == True);
			For Player Variable(Event Player, loop_j, 0, Global.settings[5], 1);
				Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[3]], Eye Position(Event Player)
					+ Facing Direction Of(Event Player) * (Evaluate Once(Event Player.loop_j * Event Player.player_cone1_dimensions[0])
					* Event Player.player_scale / Evaluate Once((Global.settings[5] - 1) * Cosine From Degrees(
					Event Player.player_cone1_dimensions[1]))), Event Player.player_scale * Evaluate Once(
					Event Player.player_cone1_dimensions[0] * Event Player.loop_j * Tangent From Degrees(Event Player.player_cone1_dimensions[1])
					/ (Global.settings[5] - 1)) / 0.985, Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				Wait(0.032, Ignore Condition);
			End;
		End;
	}
}

rule("[HANZO] dragon_fire_set_variables")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hanzo;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		"1 sec cast time"
		Wait(1, Ignore Condition);
		"set arrow launch pos and dir to temp [7] and [8]"
		Event Player.player_dragon_var[2] = Eye Position(Event Player);
		"account for straight U/D"
		Event Player.player_dragon_var[3] = Vertical Facing Angle Of(Event Player) < -89 ? World Vector Of(Up, Event Player, Rotation) : (
			Vertical Facing Angle Of(Event Player) > 89 ? World Vector Of(Down, Event Player, Rotation) : Facing Direction Of(
			Event Player));
		"wait for the dragon to appear (38t -1t)"
		Wait(0.608, Ignore Condition);
		Event Player.player_dragon_t = 0;
		"so that the hitbox will update when the dragon starts visually"
		Event Player.player_dragon_var[0] = Event Player.player_dragon_var[2];
		Event Player.player_dragon_var[1] = Event Player.player_dragon_var[3];
		Chase Player Variable At Rate(Event Player, player_dragon_t, Global.dragon_dimensions[4], Global.dragon_dimensions[3], None);
	}
}

rule("[HANZO] closest point from target to dragon spheres")
{
	event
	{
		Ongoing - Each Player;
		All;
		Hanzo;
	}

	actions
	{
		Event Player.player_dragon_var[4] = Position Of(Event Player.mhb_target)
			+ Event Player.mhb_target.self_mhb[1] * Event Player.mhb_target.player_scale + Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale * Min(
			Max(Dot Product(Eye Position(Event Player) - (Position Of(Event Player.mhb_target)
			+ Event Player.mhb_target.self_mhb[1] * Event Player.mhb_target.player_scale), Cross Product(Facing Direction Of(Event Player),
			Cross Product(Facing Direction Of(Event Player), Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale)))
			/ Dot Product(Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale, Cross Product(Facing Direction Of(
			Event Player), Cross Product(Facing Direction Of(Event Player),
			Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale))), 0), 1);
		Wait(0.016, Abort When False);
		Loop If Condition Is True;
	}
}

rule("[sub] create dragon hitbox root")
{
	event
	{
		Subroutine;
		create_dragon_hitbox_root;
	}

	actions
	{
		Call Subroutine(destroy_dragon_hitbox);
		If(Hero Of(Event Player) == Hero(Hanzo));
			If(Is Dummy Bot(Event Player) != True);
				Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("Dist to Dragon Plane"), String("{0} {1}", Dot Product(
					Event Player.player_dragon_var[1], Position Of(Event Player.mhb_target) - Event Player.player_dragon_var[0])
					- Global.dragon_dimensions[2], Custom String("m")), String("({0})", Dot Product(Facing Direction Of(Event Player), Position Of(
					Event Player.mhb_target) - Eye Position(Event Player)) - Global.dragon_dimensions[2])), Null, Null, Left, 20,
					Global.color_global[Global.color_settings[4]], Color(White), Color(White), String, Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
				Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("Dist to Dragon Body"), String("{0} {1}", 100 * (
					Distance Between(Event Player.player_dragon_var[0] + (Round To Integer(Min(Max(Dot Product(Event Player.player_dragon_var[1],
					Event Player.player_dragon_var[4] - Event Player.player_dragon_var[0]) - Event Player.player_dragon_t, -20), 10) / 5,
					To Nearest) * 5 + Event Player.player_dragon_t) * Event Player.player_dragon_var[1], Event Player.player_dragon_var[4])
					- Global.dragon_dimensions[0] - Event Player.mhb_target.player_scale * Event Player.mhb_target.self_mhb[0]), Custom String(
					"cm")), String("({0})", 100 * (Distance Between(Event Player.player_dragon_var[4], Eye Position(Event Player)
					+ Facing Direction Of(Event Player) * Dot Product(Facing Direction Of(Event Player),
					Event Player.player_dragon_var[4] - Eye Position(Event Player)))
					- Global.dragon_dimensions[0] - Event Player.mhb_target.player_scale * Event Player.mhb_target.self_mhb[0]))), Null, Null,
					Left, 21, Global.color_global[Global.color_settings[4]], Color(White), Color(White), String, Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
				Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("Dist to Dragon Center"), String("{0} {1}", 100 * (
					Distance Between(Vector(0, 0, 0), Event Player.player_dragon_var[0] - Position Of(Event Player.mhb_target) - Dot Product(
					Event Player.player_dragon_var[0] - Position Of(Event Player.mhb_target), Event Player.player_dragon_var[1])
					* Event Player.player_dragon_var[1]) - Global.dragon_dimensions[1]), Custom String("cm")), String("({0})", 100 * (
					Distance Between(Vector(0, 0, 0), Eye Position(Event Player) - Position Of(Event Player.mhb_target) - Dot Product(Eye Position(
					Event Player) - Position Of(Event Player.mhb_target), Facing Direction Of(Event Player)) * Facing Direction Of(Event Player))
					- Global.dragon_dimensions[1]))), Null, Null, Left, 22, Global.color_global[Global.color_settings[5]], Color(White), Color(
					White), String, Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
				Create HUD Text(Event Player, String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ultimate)), Custom String(
					"Moving Spheres")), Null, Null, Right, -496, Global.color_global[Global.color_settings[4]], Color(White), Color(White),
					String and Color, Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
				Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("Center of"), Ability Icon String(Hero Of(Event Player), Button(
					Ultimate)), Custom String("Cylinder")), Null, Null, Right, -495.900, Global.color_global[Global.color_settings[5]], Color(
					White), Color(White), String and Color, Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			End;
			"the dragon 150dps"
			For Player Variable(Event Player, loop_j, 0, 7, 1);
				Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[4]], Event Player.player_dragon_var[0] + (
					10 + Event Player.player_dragon_t - 5 * Evaluate Once(Event Player.loop_j)) * Event Player.player_dragon_var[1],
					Global.dragon_dimensions[0], Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
			"the center of the dragon 300dps"
			For Player Variable(Event Player, loop_j, 0, Global.dragon_dimensions[5], 1);
				Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[5]], Event Player.player_dragon_var[0] + (
					Evaluate Once((1 - Event Player.loop_j / (Global.dragon_dimensions[5] - 1)) * 14 + Event Player.loop_j / (
					Global.dragon_dimensions[5] - 1) * -24) + Event Player.player_dragon_t) * Event Player.player_dragon_var[1],
					Global.dragon_dimensions[1], Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
			"temp_arr for EFFECTS"
			Global.global_total_effect_count += Count Of(Event Player.temp_arr);
			"temp_arr2 for HUD TEXT"
			Global.global_total_hudtext_count += Count Of(Event Player.temp_arr2);
			"player_effect_id[3] for dragon"
			Event Player.player_effect_id[3] = Event Player.temp_arr;
			Event Player.player_hudtext_id[3] = Event Player.temp_arr2;
			Event Player.temp_arr = Empty Array;
			Event Player.temp_arr2 = Empty Array;
		End;
	}
}

rule("[sub] destory dragon hitbox")
{
	event
	{
		Subroutine;
		destroy_dragon_hitbox;
	}

	actions
	{
		Event Player.temp_arr = Event Player.player_effect_id[3];
		Event Player.temp_arr2 = Event Player.player_hudtext_id[3];
		Event Player.player_effect_id[3] = Empty Array;
		Event Player.player_hudtext_id[3] = Empty Array;
		Call Subroutine(temparr_delete);
	}
}

rule("cam mode controls")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Reload)) == True;
	}

	actions
	{
		Event Player.player_cam_mode = (Event Player.player_cam_mode + 1) % 5;
	}
}

rule("cam mode 0")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.player_cam_mode == 0;
	}

	actions
	{
		Stop Camera(Event Player);
	}
}

rule("cam mode 1")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.player_cam_mode == 1;
	}

	actions
	{
		Start Camera(Event Player, World Vector Of(Event Player.player_scale * Vector(10, 2, 4), Event Player, Rotation And Translation),
			World Vector Of(Event Player.player_scale * Vector(0, 2, 4), Event Player, Rotation And Translation), 100);
		disabled Start Camera(Event Player, World Vector Of(Vector(10 * Event Player.player_scale, 2 * Event Player.player_scale,
			4 * Event Player.player_scale), Event Player, Rotation And Translation), World Vector Of(Vector(0,
			2 * Event Player.player_scale, 4 * Event Player.player_scale), Event Player, Rotation And Translation), 100);
	}
}

rule("cam mode 2")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.player_cam_mode == 2;
	}

	actions
	{
		Start Camera(Event Player, Event Player.mhb_target.player_scale * Vector(0, 1, 3) + Position Of(Event Player.mhb_target),
			Event Player.mhb_target.player_scale * Vector(0, 1, 0) + Position Of(Event Player.mhb_target), 0);
	}
}

rule("cam mode 3")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.player_cam_mode == 3;
	}

	actions
	{
		Start Camera(Event Player, World Vector Of(Event Player.player_scale * Vector(6, 8, 2), Event Player, Rotation And Translation),
			World Vector Of(Event Player.player_scale * Vector(-2, 0, 10), Event Player, Rotation And Translation), 100);
	}
}

rule("cam mode 4")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.player_cam_mode == 4;
	}

	actions
	{
		Start Camera(Event Player, World Vector Of(Event Player.player_scale * Vector(0, 16, 9.500), Event Player,
			Rotation And Translation), World Vector Of(Event Player.player_scale * Vector(-0.100, 0, 9.500), Event Player,
			Rotation And Translation), 100);
	}
}

rule("[sub] create flux hitbox root")
{
	event
	{
		Subroutine;
		create_flux_hitbox_root;
	}

	actions
	{
		Call Subroutine(destroy_flux_hitbox);
		If(Hero Of(Event Player) == Hero(Sigma));
			If(Is Dummy Bot(Event Player) != True);
				Create HUD Text(Event Player, String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ultimate)), Custom String(
					"Cylinder and Sphere")), Null, Null, Right, -495, Global.color_global[Global.color_settings[6]], Color(White), Color(White),
					String and Color, Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
				Create HUD Text(Event Player, String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ultimate)), Custom String(
					"**Please Target Floor**")), Null, Null, Right, -494.900, Global.color_global[Global.color_settings[6]], Color(White), Color(
					White), String and Color, Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			End;
			Create Effect(All Players(All Teams), Light Shaft, Global.color_global[Global.color_settings[6]],
				Event Player.player_flux_var + Vector(0, -5.500, 0), 8 / 0.985, Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			"Previous"
			disabled Create Effect(All Players(All Teams), Light Shaft, Color(Blue), Event Player.player_flux_var + Vector(0, -5.500, 0), 8 / 0.985,
				Visible To Position and Radius);
			disabled Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			Create Effect(All Players(All Teams), Sphere, Global.color_global[Global.color_settings[6]], Event Player.player_flux_var + Vector(
				0, -5.500, 0), 15.500 / 0.985, Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			"Previous"
			disabled Create Effect(All Players(All Teams), Sphere, Color(Blue), Event Player.player_flux_var + Vector(0, -5.500, 0), 15.500 / 0.985,
				Visible To Position and Radius);
			disabled Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			"temp_arr for EFFECTS"
			Global.global_total_effect_count += Count Of(Event Player.temp_arr);
			"temp_arr2 for HUD TEXT"
			Global.global_total_hudtext_count += Count Of(Event Player.temp_arr2);
			"player_effect_id[4] for flux"
			Event Player.player_effect_id[4] = Event Player.temp_arr;
			Event Player.player_hudtext_id[4] = Event Player.temp_arr2;
			Event Player.temp_arr = Empty Array;
			Event Player.temp_arr2 = Empty Array;
			Event Player.player_flux_var = Vector(10000, 10000, 10000);
		End;
	}
}

rule("[sub] destory flux hitbox")
{
	event
	{
		Subroutine;
		destroy_flux_hitbox;
	}

	actions
	{
		Event Player.temp_arr = Event Player.player_effect_id[4];
		Event Player.temp_arr2 = Event Player.player_hudtext_id[4];
		Event Player.player_effect_id[4] = Empty Array;
		Event Player.player_hudtext_id[4] = Empty Array;
		Call Subroutine(temparr_delete);
	}
}

rule("[SIGMA] ultimate_select_location")
{
	event
	{
		Ongoing - Each Player;
		All;
		Sigma;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
		Is Button Held(Event Player, Button(Primary Fire)) == True;
	}

	actions
	{
		Event Player.player_flux_var = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
			+ 1000 * Facing Direction Of(Event Player), Null, Event Player, False);
	}
}

rule("[sub] init_shatter_dimensions")
{
	event
	{
		Subroutine;
		init_global_shatter_var;
	}

	actions
	{
		Global.shatter_dimensions = Array(19.835, 25, 1.770, -1, 7);
		For Global Variable(loop_i, 0, Global.shatter_dimensions[4], 1);
			Modify Global Variable(shatter_dimensions, Append To Array, Global.shatter_dimensions[0] * Sine From Degrees(2 * (Global.loop_i / (
				Global.shatter_dimensions[4] - 1)) * Global.shatter_dimensions[1] - Global.shatter_dimensions[1]));
			Modify Global Variable(shatter_dimensions, Append To Array, Global.shatter_dimensions[0] * Cosine From Degrees(2 * (
				Global.loop_i / (Global.shatter_dimensions[4] - 1)) * Global.shatter_dimensions[1] - Global.shatter_dimensions[1]));
		End;
	}
}

rule("[sub] create_shatter_hitbox_root")
{
	event
	{
		Subroutine;
		create_shatter_hitbox_root;
	}

	actions
	{
		Call Subroutine(destroy_shatter_hitbox);
		If(Hero Of(Event Player) == Hero(Reinhardt));
			If(Is Dummy Bot(Event Player) != True);
				Create HUD Text(Event Player, String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ultimate)), Custom String(
					"Pie")), Null, Null, Right, -494, Global.color_global[Global.color_settings[7]], Color(White), Color(White), String and Color,
					Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
				Create HUD Text(Event Player, String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ultimate)), Custom String(
					"**Flat Terrain Only**")), Null, Null, Right, -493.900, Global.color_global[Global.color_settings[7]], Color(White), Color(
					White), String and Color, Default Visibility);
				Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
			End;
			"r"
			Create Beam Effect(All Players(All Teams), Good Beam, World Vector Of(Event Player.player_scale * Vector(
				0.050 * Global.shatter_dimensions[5], 0, 0.050 * Global.shatter_dimensions[6]) + Vector(0, Global.shatter_dimensions[2], 0),
				Event Player, Rotation And Translation), World Vector Of(Event Player.player_scale * Vector(Global.shatter_dimensions[5], 0,
				Global.shatter_dimensions[6]) + Vector(0, Global.shatter_dimensions[2], 0), Event Player, Rotation And Translation),
				Global.color_global[Global.color_settings[7]], Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			"l"
			Create Beam Effect(All Players(All Teams), Good Beam, World Vector Of(Event Player.player_scale * Vector(
				0.050 * Global.shatter_dimensions[2 * Global.shatter_dimensions[4] + 3], 0,
				0.050 * Global.shatter_dimensions[2 * Global.shatter_dimensions[4] + 4]) + Vector(0, Global.shatter_dimensions[2], 0),
				Event Player, Rotation And Translation), World Vector Of(Event Player.player_scale * Vector(
				Global.shatter_dimensions[2 * Global.shatter_dimensions[4] + 3], 0,
				Global.shatter_dimensions[2 * Global.shatter_dimensions[4] + 4]) + Vector(0, Global.shatter_dimensions[2], 0), Event Player,
				Rotation And Translation), Global.color_global[Global.color_settings[7]], Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			"rdown"
			Create Beam Effect(All Players(All Teams), Good Beam, World Vector Of(Event Player.player_scale * Vector(
				Global.shatter_dimensions[5], 0, Global.shatter_dimensions[6]) + Vector(0, Global.shatter_dimensions[2], 0), Event Player,
				Rotation And Translation), World Vector Of(Event Player.player_scale * Vector(Global.shatter_dimensions[5], 0,
				Global.shatter_dimensions[6]) + Vector(0, Global.shatter_dimensions[3], 0), Event Player, Rotation And Translation),
				Global.color_global[Global.color_settings[6]], Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			"ldown"
			Create Beam Effect(All Players(All Teams), Good Beam, World Vector Of(Event Player.player_scale * Vector(
				Global.shatter_dimensions[2 * Global.shatter_dimensions[4] + 3], 0,
				Global.shatter_dimensions[2 * Global.shatter_dimensions[4] + 4]) + Vector(0, Global.shatter_dimensions[2], 0), Event Player,
				Rotation And Translation), World Vector Of(Event Player.player_scale * Vector(
				Global.shatter_dimensions[2 * Global.shatter_dimensions[4] + 3], 0,
				Global.shatter_dimensions[2 * Global.shatter_dimensions[4] + 4]) + Vector(0, Global.shatter_dimensions[3], 0), Event Player,
				Rotation And Translation), Global.color_global[Global.color_settings[7]], Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			"anim_rdown"
			Create Beam Effect(All Players(All Teams), Good Beam, World Vector Of(Event Player.player_scale * Vector(
				Total Time Elapsed / 4 % 1 * Global.shatter_dimensions[5], 0, Total Time Elapsed / 4 % 1 * Global.shatter_dimensions[6])
				+ Vector(0, Global.shatter_dimensions[2], 0), Event Player, Rotation And Translation), World Vector Of(
				Event Player.player_scale * Vector(Total Time Elapsed / 4 % 1 * Global.shatter_dimensions[5], 0,
				Total Time Elapsed / 4 % 1 * Global.shatter_dimensions[6]) + Vector(0, Global.shatter_dimensions[3], 0), Event Player,
				Rotation And Translation), Global.color_global[Global.color_settings[7]], Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			"anim_ldown"
			Create Beam Effect(All Players(All Teams), Good Beam, World Vector Of(Event Player.player_scale * Vector(Absolute Value(
				Total Time Elapsed / 4 % 1 - 1) * Global.shatter_dimensions[2 * Global.shatter_dimensions[4] + 3], 0, Absolute Value(
				Total Time Elapsed / 4 % 1 - 1) * Global.shatter_dimensions[2 * Global.shatter_dimensions[4] + 4]) + Vector(0,
				Global.shatter_dimensions[2], 0), Event Player, Rotation And Translation), World Vector Of(Event Player.player_scale * Vector(
				Absolute Value(Total Time Elapsed / 4 % 1 - 1) * Global.shatter_dimensions[2 * Global.shatter_dimensions[4] + 3], 0,
				Absolute Value(Total Time Elapsed / 4 % 1 - 1) * Global.shatter_dimensions[2 * Global.shatter_dimensions[4] + 4]) + Vector(0,
				Global.shatter_dimensions[3], 0), Event Player, Rotation And Translation), Global.color_global[Global.color_settings[7]],
				Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			"anim_curve"
			Create Beam Effect(All Players(All Teams), Good Beam, World Vector Of(Event Player.player_scale * Vector(
				Global.shatter_dimensions[0] * Sine From Degrees(2 * Global.shatter_dimensions[1] * (Total Time Elapsed / 4 % 1)
				- Global.shatter_dimensions[1]), 0, Global.shatter_dimensions[0] * Cosine From Degrees(2 * Global.shatter_dimensions[1] * (
				Total Time Elapsed / 4 % 1) - Global.shatter_dimensions[1])) + Vector(0, Global.shatter_dimensions[2], 0), Event Player,
				Rotation And Translation), World Vector Of(Event Player.player_scale * Vector(Global.shatter_dimensions[0] * Sine From Degrees(
				2 * Global.shatter_dimensions[1] * (Total Time Elapsed / 4 % 1) - Global.shatter_dimensions[1]), 0,
				Global.shatter_dimensions[0] * Cosine From Degrees(2 * Global.shatter_dimensions[1] * (Total Time Elapsed / 4 % 1)
				- Global.shatter_dimensions[1])) + Vector(0, Global.shatter_dimensions[3], 0), Event Player, Rotation And Translation),
				Global.color_global[Global.color_settings[7]], Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			For Player Variable(Event Player, loop_j, 0, Global.shatter_dimensions[4] - 1, 1);
				"Curve"
				Create Beam Effect(All Players(All Teams), Good Beam, World Vector Of(Event Player.player_scale * Evaluate Once(Vector(
					Global.shatter_dimensions[5 + 2 * Event Player.loop_j], 0, Global.shatter_dimensions[6 + 2 * Event Player.loop_j])) + Vector(0,
					Global.shatter_dimensions[2], 0), Event Player, Rotation And Translation), World Vector Of(
					Event Player.player_scale * Evaluate Once(Vector(Global.shatter_dimensions[7 + 2 * Event Player.loop_j], 0,
					Global.shatter_dimensions[8 + 2 * Event Player.loop_j])) + Vector(0, Global.shatter_dimensions[2], 0), Event Player,
					Rotation And Translation), Global.color_global[Global.color_settings[7]], Visible To Position and Radius);
				Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				"Down"
				disabled Create Beam Effect(All Players(All Teams), Good Beam, World Vector Of(Event Player.player_scale * Evaluate Once(Vector(
					Global.shatter_dimensions[7 + 2 * Event Player.loop_j], 0, Global.shatter_dimensions[8 + 2 * Event Player.loop_j])) + Vector(0,
					Global.shatter_dimensions[2], 0), Event Player, Rotation And Translation), World Vector Of(
					Event Player.player_scale * Evaluate Once(Vector(Global.shatter_dimensions[7 + 2 * Event Player.loop_j], 0,
					Global.shatter_dimensions[8 + 2 * Event Player.loop_j])) + Vector(0, Global.shatter_dimensions[3], 0), Event Player,
					Rotation And Translation), Color(White), Visible To Position and Radius);
				disabled Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
				Wait(0.016, Ignore Condition);
			End;
			"shaft"
			Create Effect(All Players(All Teams), Light Shaft, Global.color_global[Global.color_settings[7]], Position Of(Event Player),
				Event Player.player_scale * Event Player.player_shatter_var / 0.985, Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			"ring"
			Create Effect(All Players(All Teams), Ring, Global.color_global[Global.color_settings[7]], Position Of(Event Player),
				Event Player.player_scale * Global.shatter_dimensions[0] / 0.985, Visible To Position and Radius);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			"temp_arr for EFFECTS"
			Global.global_total_effect_count += Count Of(Event Player.temp_arr);
			"temp_arr2 for HUD TEXT"
			Global.global_total_hudtext_count += Count Of(Event Player.temp_arr2);
			"player_effect_id[5] for shatter"
			Event Player.player_effect_id[5] = Event Player.temp_arr;
			Event Player.player_hudtext_id[5] = Event Player.temp_arr2;
			Event Player.temp_arr = Empty Array;
			Event Player.temp_arr2 = Empty Array;
			"DO NOT DELETE UNTIL _visible HAVE OTHER USES"
			disabled Event Player.player_effect_visible[5] = Empty Array;
		End;
	}
}

rule("[sub] destory_shatter_hitbox")
{
	event
	{
		Subroutine;
		destroy_shatter_hitbox;
	}

	actions
	{
		Event Player.temp_arr = Event Player.player_effect_id[5];
		Event Player.temp_arr2 = Event Player.player_hudtext_id[5];
		Event Player.player_effect_id[5] = Empty Array;
		Event Player.player_hudtext_id[5] = Empty Array;
		Call Subroutine(temparr_delete);
	}
}

rule("[REIN] using_shatter")
{
	event
	{
		Ongoing - Each Player;
		All;
		Reinhardt;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Event Player.player_shatter_var = 0.650;
		Chase Player Variable Over Time(Event Player, player_shatter_var, Global.shatter_dimensions[0], 0.480, None);
		Wait(1, Ignore Condition);
		Stop Chasing Player Variable(Event Player, player_shatter_var);
		Event Player.player_shatter_var = 0;
	}
}

rule("toggle_melee_hitbox")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Group Up) == True;
	}

	actions
	{
		Event Player.melee_hitbox_temp_disable = 2 + (Event Player.melee_hitbox_temp_disable + 1) % 2;
		"destroy"
		If(Event Player.melee_hitbox_temp_disable == 3);
			Call Subroutine(destroy_melee_hitbox);
		Else If(Event Player.melee_hitbox_temp_disable == 2);
			If(Is Using Ultimate(Event Player) && Hero Of(Event Player) == Hero(Winston));
				Call Subroutine(create_primal_hitbox);
			Else If(Hero Of(Event Player) == Hero(Reinhardt));
				Call Subroutine(create_melee_hitbox_reinhammer);
			Else If(Hero Of(Event Player) == Hero(Brigitte));
				Call Subroutine(pass);
			Else;
				Call Subroutine(create_melee_hitbox_quick);
			End;
		End;
	}
}

rule("[SCALE] enlarge")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Crouch)) != True;
		Is Button Held(Event Player, Button(Interact)) != True;
	}

	actions
	{
		Wait(2, Abort When False);
		Call Subroutine(scale_up);
	}
}

rule("[SCALE] shrink")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Jump)) != True;
		Is Button Held(Event Player, Button(Interact)) != True;
	}

	actions
	{
		Wait(2, Abort When False);
		Call Subroutine(scale_down);
	}
}

rule("[SCALE] stop scale")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) != True;
		Is Button Held(Event Player, Button(Jump)) != True;
		Is Button Held(Event Player, Button(Interact)) != True;
	}

	actions
	{
		Call Subroutine(scale_stop);
	}
}

rule("[SCALE] reset scale")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Interact)) != True;
	}

	actions
	{
		Call Subroutine(scale_reset);
	}
}

rule("[SCALE BOT] enlarge")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Crouch)) != True;
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Dummy Bot(Event Player.mhb_target) == True;
	}

	actions
	{
		Wait(2, Abort When False);
		Event Player.mhb_target.player_scale_controls[0] = True;
	}
}

rule("[SCALE BOT] shrink")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Jump)) != True;
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Dummy Bot(Event Player.mhb_target) == True;
	}

	actions
	{
		Wait(2, Abort When False);
		Event Player.mhb_target.player_scale_controls[1] = True;
	}
}

rule("[SCALE BOT] stop scale")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) != True;
		Is Button Held(Event Player, Button(Jump)) != True;
		Is Button Held(Event Player, Button(Interact)) != True;
		Is Dummy Bot(Event Player.mhb_target) == True;
	}

	actions
	{
		Event Player.mhb_target.player_scale_controls[2] = True;
	}
}

rule("[SCALE BOT] reset scale")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Button Held(Event Player, Button(Crouch)) == True;
		Is Button Held(Event Player, Button(Jump)) == True;
		Is Button Held(Event Player, Button(Interact)) == True;
		Is Dummy Bot(Event Player.mhb_target) == True;
	}

	actions
	{
		Event Player.mhb_target.player_scale_controls[3] = True;
	}
}

rule("[SCALE BOT] bot - up true")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.player_scale_controls[0] == True;
	}

	actions
	{
		Call Subroutine(scale_up);
	}
}

rule("[SCALE BOT] bot - down true")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.player_scale_controls[1] == True;
	}

	actions
	{
		Call Subroutine(scale_down);
	}
}

rule("[SCALE BOT] bot - stop true")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.player_scale_controls[2] == True;
	}

	actions
	{
		Call Subroutine(scale_stop);
	}
}

rule("[SCALE BOT] bot - reset true")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Event Player.player_scale_controls[3] == True;
	}

	actions
	{
		Call Subroutine(scale_reset);
	}
}

rule("[sub] [SCALE] up")
{
	event
	{
		Subroutine;
		scale_up;
	}

	actions
	{
		Event Player.player_scale_controls[0] = False;
		Start Scaling Player(Event Player, Event Player.player_scale, True);
		Chase Player Variable At Rate(Event Player, player_scale, 20, Event Player.player_scale ^ (
			-0.050 * Event Player.player_scale + 1.100), Destination and Rate);
	}
}

rule("[sub] [SCALE] down")
{
	event
	{
		Subroutine;
		scale_down;
	}

	actions
	{
		Event Player.player_scale_controls[1] = False;
		Start Scaling Player(Event Player, Event Player.player_scale, True);
		Chase Player Variable At Rate(Event Player, player_scale, 0.100, Event Player.player_scale ^ (
			-0.050 * Event Player.player_scale + 1.100), Destination and Rate);
	}
}

rule("[sub] [SCALE] stop")
{
	event
	{
		Subroutine;
		scale_stop;
	}

	actions
	{
		Event Player.player_scale_controls[2] = False;
		Stop Chasing Player Variable(Event Player, player_scale);
	}
}

rule("[sub] [SCALE] reset")
{
	event
	{
		Subroutine;
		scale_reset;
	}

	actions
	{
		Event Player.player_scale_controls[3] = False;
		Stop Scaling Player(Event Player);
		Stop Chasing Player Variable(Event Player, player_scale);
		Event Player.player_scale = 1;
	}
}

rule("[sub] effect hudtext temp_arr delete")
{
	event
	{
		Subroutine;
		temparr_delete;
	}

	actions
	{
		"count subtract"
		Global.global_total_effect_count -= Count Of(Event Player.temp_arr);
		Global.global_total_hudtext_count -= Count Of(Event Player.temp_arr2);
		"destroy effects"
		While(Event Player.temp_arr != Empty Array);
			Destroy Effect(Event Player.temp_arr[0]);
			Modify Player Variable(Event Player, temp_arr, Remove From Array By Index, 0);
			Wait(0.016, Ignore Condition);
		End;
		"destroy hudtext"
		While(Event Player.temp_arr2 != Empty Array);
			Destroy HUD Text(Event Player.temp_arr2[0]);
			Modify Player Variable(Event Player, temp_arr2, Remove From Array By Index, 0);
			Wait(0.016, Ignore Condition);
		End;
		"reset"
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
	}
}

rule("[DVA] demech")
{
	event
	{
		Ongoing - Each Player;
		All;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) == True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.self_mhb_temp = Array(0, 0, 0);
		Call Subroutine(decompress_mhb_matrix);
	}
}

rule("[DVA] remech")
{
	event
	{
		Ongoing - Each Player;
		All;
		D.Va;
	}

	conditions
	{
		Is In Alternate Form(Event Player) != True;
		Has Spawned(Event Player) == True;
	}

	actions
	{
		Event Player.self_mhb_temp = Array(1, 0, 1);
		Call Subroutine(decompress_mhb_matrix);
	}
}

rule("teleport_bot_to_this_position")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	conditions
	{
		Is Communicating(Event Player, Hello) == True;
		Is Dummy Bot(Event Player) != True;
	}

	actions
	{
		Teleport(Event Player.mhb_target, Position Of(Event Player));
		Set Facing(Event Player.mhb_target, Facing Direction Of(Event Player), To World);
	}
}

rule("[sub] create_primal_hitbox")
{
	event
	{
		Subroutine;
		create_primal_hitbox;
	}

	actions
	{
		"no need to create hud text for dummies"
		If(Is Dummy Bot(Event Player) != True);
			Create HUD Text(Event Player, String("{0} {1}", Ability Icon String(Hero Of(Event Player), Button(Ultimate)), Custom String(
				"Moving Spheres")), Null, Null, Right, -498, Event Player.player_effect_colors_melee[13], Color(White), Color(White),
				String and Color, Default Visibility);
			Modify Player Variable(Event Player, temp_arr2, Append To Array, Last Text ID);
		End;
		"rein hammer hitbox color"
		Event Player.player_effect_colors_melee = Array(Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]], Global.color_global[Global.color_settings[1]],
			Global.color_global[Global.color_settings[1]]);
		"rein hammer data"
		Event Player.temp_arr3 = Array(Vector(-2, 0, 3), Vector(-1.120, 0, 3), Vector(-0.480, 0, 3), Vector(0.160, 0, 3), Vector(0.800, 0,
			3), Vector(1.440, 0, 3), Vector(2, 0, 3), Vector(1.280, 0, 3), Vector(0.640, 0, 3), Vector(0, 0, 3), Vector(-0.640, 0, 3),
			Vector(-1.280, 0, 3), Vector(-1.920, 0, 3));
		"create rein hammer hitbox"
		For Player Variable(Event Player, loop_j, 0, Count Of(Event Player.temp_arr3), 1);
			Create Effect(All Players(All Teams), Sphere, Event Player.player_effect_colors_melee[Evaluate Once(Event Player.loop_j)],
				Eye Position(Event Player) + Event Player.player_scale * (World Vector Of(Left, Event Player, Rotation) * Evaluate Once(
				X Component Of(Event Player.temp_arr3[Event Player.loop_j])) + Direction From Angles(Horizontal Facing Angle Of(Event Player),
				Vertical Facing Angle Of(Event Player) - 90) * Evaluate Once(Y Component Of(Event Player.temp_arr3[Event Player.loop_j]))
				+ Facing Direction Of(Event Player) * Evaluate Once(Z Component Of(Event Player.temp_arr3[Event Player.loop_j]))),
				1 * Event Player.player_scale / 0.985, Visible To Position Radius and Color);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			Create Effect(All Players(All Teams), Sphere, Event Player.player_effect_colors_melee[Evaluate Once(Event Player.loop_j)],
				Eye Position(Event Player) + Event Player.player_scale * (World Vector Of(Left, Event Player, Rotation) * Evaluate Once(
				X Component Of(Event Player.temp_arr3[Event Player.loop_j]) / 2) + Direction From Angles(Horizontal Facing Angle Of(
				Event Player), Vertical Facing Angle Of(Event Player) - 90) * Evaluate Once(Y Component Of(
				Event Player.temp_arr3[Event Player.loop_j]) / 2) + Facing Direction Of(Event Player) * Evaluate Once(Z Component Of(
				Event Player.temp_arr3[Event Player.loop_j]) / 2)), 0.500 * Event Player.player_scale / 0.985,
				Visible To Position Radius and Color);
			Modify Player Variable(Event Player, temp_arr, Append To Array, Last Created Entity);
			Wait(0.016, Ignore Condition);
		End;
		"temp_arr for EFFECTS"
		Global.global_total_effect_count += Count Of(Event Player.temp_arr);
		"temp_arr2 for HUD TEXT"
		Global.global_total_hudtext_count += Count Of(Event Player.temp_arr2);
		"player_effect_id[1] for melee"
		Modify Player Variable At Index(Event Player, player_effect_id, 1, Append To Array, Event Player.temp_arr);
		Modify Player Variable At Index(Event Player, player_hudtext_id, 1, Append To Array, Event Player.temp_arr2);
		disabled Event Player.player_effect_id[1] = Event Player.temp_arr;
		disabled Event Player.player_hudtext_id[1] = Event Player.temp_arr2;
		Event Player.temp_arr = Empty Array;
		Event Player.temp_arr2 = Empty Array;
		Event Player.temp_arr3 = Empty Array;
	}
}

rule("[WINSTON] primal_startend")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Call Subroutine(destroy_melee_hitbox);
		Call Subroutine(create_primal_hitbox);
		Event Player.melee_hitbox_temp_disable = 0;
		Wait Until(!Is Using Ultimate(Event Player), 99999);
		Call Subroutine(destroy_melee_hitbox);
		Call Subroutine(create_melee_hitbox_quick);
		Event Player.melee_hitbox_temp_disable = 0;
	}
}

disabled rule("[WINSTON] end_primal")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Using Ultimate(Event Player) == False;
	}

	actions
	{
		Call Subroutine(destroy_melee_hitbox);
		Call Subroutine(create_melee_hitbox_quick);
		Event Player.melee_hitbox_temp_disable = 0;
	}
}

rule("[WINSTON] winstonprimal_swing_change_color")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Firing Primary(Event Player) == True;
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Event Player.player_effect_colors_melee[13] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[2]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[1] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[2] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[1] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[3] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[2] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[4] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[3] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[5] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[4] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[6] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[5] = Global.color_global[Global.color_settings[1]];
		Wait(0.304, Ignore Condition);
		Event Player.player_effect_colors_melee[6] = Global.color_global[Global.color_settings[1]];
		Wait Until(!Is Firing Primary(Event Player), 0.544);
		Wait Until(Is Firing Primary(Event Player), 0.544);
		Abort If Condition Is False;
		Event Player.player_effect_colors_melee[13] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[7] = Global.color_global[Global.color_settings[2]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[8] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[7] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[9] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[8] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[10] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[9] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[11] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[10] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[12] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[11] = Global.color_global[Global.color_settings[1]];
		Wait(0.016, Ignore Condition);
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[2]];
		Event Player.player_effect_colors_melee[12] = Global.color_global[Global.color_settings[1]];
		Wait(0.288, Ignore Condition);
		Event Player.player_effect_colors_melee[0] = Global.color_global[Global.color_settings[1]];
	}
}

rule("[WINSTON] winstonprimal_swing_change_color_off")
{
	event
	{
		Ongoing - Each Player;
		All;
		Winston;
	}

	conditions
	{
		Is Firing Primary(Event Player) != True;
		Is Using Ultimate(Event Player) == True;
	}

	actions
	{
		Event Player.player_effect_colors_melee[13] = Global.color_global[Global.color_settings[1]];
	}
}

rule("closest point from target to dragon spheres")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Event Player.closest_pt = Position Of(Event Player.mhb_target)
			+ Event Player.mhb_target.self_mhb[1] * Event Player.mhb_target.player_scale + Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale * Min(
			Max(Dot Product(Eye Position(Event Player) - (Position Of(Event Player.mhb_target)
			+ Event Player.mhb_target.self_mhb[1] * Event Player.mhb_target.player_scale), Cross Product(Facing Direction Of(Event Player),
			Cross Product(Facing Direction Of(Event Player), Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale)))
			/ Dot Product(Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale, Cross Product(Facing Direction Of(
			Event Player), Cross Product(Facing Direction Of(Event Player),
			Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale))), 0), 1);
		Wait(0.016, Abort When False);
		Loop If Condition Is True;
	}
}

rule("Rule 74")
{
	event
	{
		Ongoing - Each Player;
		All;
		All;
	}

	actions
	{
		Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("Hook"), String("{0} {1}", 2345, String("({0})", 100 * (
			Distance Between(Event Player.closest_pt, Eye Position(Event Player) + Facing Direction Of(Event Player) * Dot Product(
			Facing Direction Of(Event Player), Event Player.closest_pt - Eye Position(Event Player)))
			- 0 - Event Player.mhb_target.player_scale * Event Player.mhb_target.self_mhb[0])))), Null, Null, Left, 21,
			Global.color_global[Global.color_settings[4]], Color(White), Color(White), String, Default Visibility);
		"melee predict"
		Create HUD Text(Event Player, String("{0} {1} {2}", Custom String("hook distance"), 100 * (Distance Between(Eye Position(
			Event Player) + 20 * Event Player.player_scale * Facing Direction Of(Event Player), Position Of(Event Player.mhb_target)
			+ Event Player.mhb_target.self_mhb[1] * Event Player.mhb_target.player_scale + Min(Max(Dot Product(Eye Position(Event Player)
			+ 20 * Event Player.player_scale * Facing Direction Of(Event Player) - Position Of(Event Player.mhb_target)
			- Event Player.mhb_target.self_mhb[1] * Event Player.mhb_target.player_scale,
			Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale) / Dot Product(
			Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale,
			Event Player.mhb_target.self_mhb[3] * Event Player.mhb_target.player_scale), 0), 1)
			* Event Player.mhb_target.player_scale * Event Player.mhb_target.self_mhb[3])
			- Event Player.mhb_target.self_mhb[0] * Event Player.mhb_target.player_scale - 0.500 * Event Player.player_scale),
			Custom String("cm")), Null, Null, Left, 2, Global.color_global[Global.color_settings[2]], Color(White), Color(White), String,
			Default Visibility);
		Create Effect(All Players(All Teams), Sphere, Color(White), Eye Position(Event Player) + 20 * Facing Direction Of(Event Player),
			0.500 * 1.015, Visible To Position and Radius);
	}
}

rule("Rule 75")
{
	event
	{
		Player Dealt Damage;
		All;
		Roadhog;
	}

	conditions
	{
		Is Using Ability 1(Event Player) == True;
	}

	actions
	{
		Set Status(Event Player, Null, Hacked, 0.016);
	}
}